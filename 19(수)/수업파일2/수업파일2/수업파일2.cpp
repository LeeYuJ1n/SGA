#include <iostream>
#include "Human.h"
#include "Student.h"
#include "Vendor.h"
#include "ProGamer.h"

// 오버라이드를 응용해서 클래스별로 다른 기능을, 하나의 호출로 때우는 방법

int main()
{
    // 함수 오버라이드를 클래스에서 응용하면 클래스 입장에서는 편하다
    // → 클래스마다 맞춤 함수를 만들 수 있으니까

    // 반면에 그 클래스를 써야 되는 입장이 되면 약간 골치아파진다
    // → 클래스가 만들어지고 함수가 늘어날수록 대응해야 하는 대책도 많아지니까

    // 그래서 클래스를 쓰는 입장에서, 미리 하나의 함수만 만들어놓으면
    // 다음 자식 클래스를 만드는 쪽에서 일일이 정해진 절차에 먼저 대응하게끔 만들 수도 있다
    // → 함수 오버라이드를 써서

    // 예시

    // 인간이라는 클래스가 있다면 직업은 자식 클래스
    // 직업이 가지는 "생활"의  함수는 직업마다 천차만별
    // 그런데 그 직업의 행동을 일일이 코드로 불러내려면 아마 시간이 부족할 것

    // 그래서 코드를 만들 때, 그냥 "인간은 생활한다"고만 호출하면 되도록 해두고
    // 각 직업을 코드로 작성할 때, "그 생활이란 ~~~다"라고 작성 중에 대응을 하도록 할 것

    // 그러면 각 직업을 호출 할 때도 그냥 "~~~직업은 생활한다"고만 호출해도 될 것

    // -----------------------------------------

    // 가상 함수(와 그 함수를 사용한 각 자식 클래스를 활용하기)

    // Human* human = new Human(); ← 현재는 이렇게 못 만든다 : 조금 뒤에 설명

    Student* stu = new Student(); // ← 자식 클래스는 만들 수 있음

    // 위는 일반적인 인스턴스 작성 방식

    Human* stu_v = new Student(); // ← 자식 클래스의 인스턴스를 만들었는데, 사용은 "인간"인 것처러 하겠다는 뜻
    // 이건 다소 특이한 인스턴스 작성 방식. 개별 자식 클래스를 만들되, 취급은 "인간"으로 한다

    Human* ven_v = new Vendor(); // 노점상도
    Human* pro_v = new ProGamer(); // 프로게이머도 이렇게 만들어보기

    // 그리고 "인간"의 포인터를 생성

    Human* hPtr = stu_v; // 인간의 포인터 생성 후, 학생을 지정
    
    hPtr -> Live(); // 이 "인간"은 어떻게 사는가?
    hPtr = ven_v; // 포인터의 대상을 노점상으로 변경
    // 원래는 못 하는 연산이지만, 지금 만든 인스턴스들이 모두 "인간 취급"이기 때문에
    // 이런 연상상의 장난이 가능

    hPtr -> Live(); // "이 인간"은 또 어떻게 사는가? : 윗줄과 똑같은 코드

    hPtr = pro_v; // 프로게이머로 또 변경

    hPtr -> Live(); // "이 인간"은 또 어떻게 사는가? : 윗줄과 똑같은 코드

    // 이런 기법을 응용하는 방법 : 
    
    // 자식 클래스가 몇 종류가 됐든, 앞으로 무엇이 추가됐든 상관없이
    // "인간"이라는 클래스에서 반드시 수행해야 하는 함수가 있을 때
    // 그리고 한 번 작성된 인간용 함수를 나중에 고치기 싫을 때

    // 공용 실행 환경을 만들어놓고, 개별 자식 클래스 쪽에서 만들 때마다 대응하도록
    // 그렇게 개발을 통제하는 환경을 만들고 싶을 때, 이런 오버라이드 기법을 사용하게 된다

    // → 이 기법을 "인터페이스"라고 부른다

    // -------------------------------------------

    // 추가 : 원본 클래스가 생성자 외에, 다른 변수나 함수가 일절 없이
    //        가상 함수로만 이루어질 수도 있다
    //        이렇게 가상 함수로만 이루어진 원본 클래스는 단독으로는 아무 것도 못 한다
    //        그렇기 때문에 사실상 없는 거나 마찬가지. 혹은...
    //        "내 자식 클래스는 이런저런 함수를 기본적으로 가집니다"라는 의미를 타인과 공유만 한다

    //        이런 순수한 가상 원본 클래스를 "추상 클래스"라고 한다
}