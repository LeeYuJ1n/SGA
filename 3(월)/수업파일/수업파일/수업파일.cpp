#include <iostream>
#include <conio.h>

int main()
{
    int inputX = 0;
    int inputY = 0;

    // 다차원 배열

    // 컴퓨터에서의 정의 : 배열 속 배열, 작은 배열을 원소로 삼는 배열
    
    int arr[3][4]; // ← 정수 4개짜리 배열(int[4])을 3개 원소로 갖는 더 큰 배열

    // 위 배열을 그림으로 나타나면.....

    // [1, 2, 3, 4] ← 이게 배열 한 개
    // [5, 6, 7, 8]
    // [9, 0, 1, 2]
    
    // 이렇게 배열 세 개를 하나의 배열로 만든 것
    // [1, 2, 3, 4][5, 6, 7, 8][9, 0, 1, 2] ← 대략 이런 모양이 된다

    // 메모리에 들어갈 때는 다차원 배열 역시 한 줄로만 쭉 들어가는데
    // 사람이 호출하고 정렬하는 과정에서, 줄 바꿈 등을 하다 보면 표시 혹은 이해에 축이 생긴다

    // [1, 2, 3, 4] ← 가장 작은 배열은 가로의 역할을 하게 되고
    // [5, 6, 7, 8]
    // [9, 0, 1, 2]
    // ↑ 가장 작은 배열보다 한 단계 위쪽 배열은 세로의 역할을 하는 경우가 많다

    // 그래서 다*차원*배열

    int triDim[2][3][4]; // ← 이렇게 3차원 배열이 된다면?

    // 3차원 배열은 그림으로 나타내자면 이렇게 된다

    // 1층 : [0][0][0]부터 [0][2][3]
    // [1, 2, 3, 4]
    // [5, 6, 7, 8]
    // [9, 0, 1, 2]

    // 2층 : [1][0][0]부터 [1][2][3]
    // [1, 2, 3, 4]
    // [5, 6, 7, 8]
    // [9, 0, 1, 2]

    // 이렇게 층을 나누어서 2차원 배열의 나열로 표시할 수 있습니다

    // 컴퓨터 프로그래밍 언어에서는 이론상 무한하게 배열의 중복을 만들 수는 있다
    // 다만 두 가지 제약 때문에 현실적으로 4차원 이상의 배열은 거의 쓰지 않는다

    // 제약 1 : 배열도 결국 변수이므로, 메모리의 크기를 넘어서는 크기로 만들 수는 없다
    //          (1차원 변수 1억 개짜리, 혹은 10차원 배열 등.....)
    
    // 제약 2 : 우리 자신이 차원을 지나치게 증복해서 이해하기는 힘들다
    //          (개인차는 있지만, 평균 인간이 직관적으로 이해하는 차원은 4차원, 필기 등의 수단을 동원하면 훈련받은 사람이 이해하는 차원의 십수 차원 이내)

    // 2차원 배열 출력해보기
    int douDim[4][5] = { 
        1, 2, 3, 4, 5, 
        6, 7, 8, 9, 10, 
        11, 12, 13, 14, 15, 
        16, 17, 18, 19, 20 };

    for (int i = 0; i < 4; ++i) // 큰 쪽 배열을 위한 반복문(왼쪽 배열용)
    {
        for (int j = 0; j < 5; ++j) // 작은 쪽 배열을 위한 반복문(오른쪽용)
        {
            std::cout << douDim[i][j] << " ";
        }
        // j 반복문이 다 돌아가면 i 반복문이 한 번(+1)돌아간다

        std::cout << std::endl; // i가 한 번 돌아갈 때마다 줄바꿈 한 번
    }

    // 2차원 배열 출력하기 2탄(칸 맞추기와 특정 위치 표시 바꾸기)

    // 위에서 만든 2차원 배열 재활용

    std::cout << std::endl; // 줄바꿈 2번(보기 쉽게)
    std::cout << std::endl;

    // 표시를 바꾸기 위한 특정 위치를 지정하는 변수
    int x = 0;
    int y = 0;
    char Enter;

    // 변수 x값 입력
    std::cout << "X값 입력 : ";
    std::cin >> inputX;

    // 변수 y값 입력
    std::cout << "Y값 입력 : ";
    std::cin >> inputX;

    // 값 대입하기
    x = inputX;
    y = inputY;

    // 엔터입력을 기다리는 코드
    std::cout << "엔터키를 누르면 결과가 나옵니다\n";
    Enter = _getch();

    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 5; ++j)
        {
            if (douDim[i][j] < 10) // 출력하려는 값이 한 자릿수면
            {
                if (j != x || i != y)
                {
                    std::cout << " "; // 앞에 한 칸을 띄워주기
                }
            }

            // if문 구상 팁 : 더 많은 경우의 수가 더 먼저 실행되도록 하면 좋습니다
            if (j != x || i != y) // 지금 칸의 가로, 세로가 x, y와 다를 때
            {
                std::cout << douDim[i][j] << " " << "\t"; // 공백을 일부러 2번 넣기(가로 구분 맞추기)

                // \t : "이 다음에 오는 기호 중 몇 가지는 특수 처리됩니다."라는 뜻의 연산자
                // \: 기호와 다음 기호를 조합한 표현 문자를 특수 문자라고 한다
                // 특수 문자 중에서 자주 사용되는 특수 문자 3개
                // \n : w줄을 바꾸겠다는 뜻의 특수 문자. std::endl;하고 같은 뜻
                // \t : 들여쓰기를 하겠다는 뜻의 특수 문자.
                // 컴퓨터의 들여쓰기는 (워드프로세서 아님) 일반 스페이스보다 칸을 아주 많이 띄운다
                // 이 때, 들여쓰기가 스페이스 몇 번째리냐는 os마다, 타이핑 환경마다 다르다...무조건 몇 칸이라는 정의는 없다
                // \" : 이 큰따옴표는 문자열 표시의 끝이 아니고 그냥 큰따옴표라는 문자라는 뜻
            }
            else std::cout<< "■" << "\t"; // 지정된 위치의 표시는 2바이트짜리 다른 문자로

            /*
            if (j == x && i == y) // 지금 칸의 가로, 세로가 x, y와 값이 같을 때(지정된 위치)
            {
                std::cout << "■" << " "; // 지정된 위치의 표시는 2바이트짜리 다른 문자로
            }
            else
            {
                std::cout << douDim[i][j] << " " << " "; // 공백을 일부러 2번 넣기(가로 구분 맞추기)
            }
            */
        }

        std::cout << std::endl;
    }
}