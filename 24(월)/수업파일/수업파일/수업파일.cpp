#include <iostream>
#include <vector>

using namespace std;

int main()
{
    // 벡터 만들기
    vector<int> vec;

    // 벡터 채우기
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    // 벡터 채우기(함수와 반복문 쓰기)

    vec.resize(10); //  ← 벡터에 크기를 미리 예약하는 함수
    // 딱히 뭘 입력을 안 해도, 지금 이 벡터에는 숫자 한 10개쯤은 들어간다
    // (10 + @)

    for (int i = 0; i < 10; ++i) // 반복문으로 값 일괄 할당하기
        // 리사이즈로 예약한 숫자를 넘지 않도록 주의
        // → 이런 식으로 벡터가 값을 주지 않은 메모리 영역에
        //    접근해서 값을 넣거나 쓰려고 하면 오류가 난다
        
        // → 이 상황을 현장에서는 흔히 벡터가 터진다고 표현한다
    {
        vec[i] = i;
        cout << vec[i] << endl; // 출력까지 한 번에
    }

    // 벡터가 터지는 걸 막으려면 : 
    // 1. 애초에 벡터의 크기를 잘 계산해서 함부로 넘지 않도록 조심
    // (그 과정에서 벡터.size() 함수가 빈번히 쓰인다)
    // + 벡터의 메모리 위치 등의 데이터를 아는 것도 좋을지도

    // 여기서, 배열은 포인터였다. 그럼, 벡터는?

    // cout << vec << endl; ← 오류. 벡터는 배열처럼 쓰지 못 한다
    // 진짜 배열은 아니니까(C++이라는 언어에서 벡터는 클래스)

    // ---------------------------------------------------------
    // → 그래서 벡터의 메모리 위치를 알려면 다른 ㅂ특별한 방법을 써야 한다
    // 다행히 C++에서는 벡터에서 메모리 위치를 알게 해주는 전용 기능이 있다
    // 그 기능의 이름은 "반복자"라고 한다(iterator, "순찰자")

    // 반복자의 사용
    vector<int>::iterator it = vec.begin();

    // 이어서 it 출력 (바로는 못 쓴다)
    // cout << it << endl; // ← 반복자도 알고 보니 클래스...

    // 하지만 반복자에는 반복자 자체의 사용 방법이 따로 있다
    cout << *it << endl; // ← 사용 가능

    // 반복자의 데이터 의미는 벡터의 메모리 "정보" (위치 + @)
    // 그렇기 때문에 바로 출력은 못 하지만, 값을 호출할 수 있다

    // 이어서 반복자에는 ++, -- 연산 가능
    it++;
    it++; // ← 이 코드 한 번마다 순번이 1 올라간다
    it++;
    it++;

    cout << *it << endl; // 다시 호출하면

    // 이렇게 반복자의 존재와 사용 방법을 응용하면

    for (vector<int>::iterator it2 = vec.begin();
        it2 != vec.end();
        it2++)
    {
        cout << *it2 << endl; // 이렇게도 벡터 출력 가능
    }

    // 반복자를 이용하면 벡터의 관리를 포인터처럼 쓰기 보다
    // 클래스 내의 메모리 정보를 이용해서 진행할 수도 있다

    // 그러면 왜 []대신에 이걸 왜 쓰느냐? + 반복자에는 어떤 정보가 들어가느냐?
    // []을 대신할 수 있는 이유 : 벡터 자체의 메모리를 참조해서 더 정확
    // 반복자의 구성 정보(중 핵심 2가지)
    // 1. 내 메모리 위치(벡터 + 현재 값)
    // 2. 벡터 속 "다음 구성요소의 위치"

    // -----------------------------------------------------------------------

    // 반복자의 다른 응용 : insert, emplace, ersae에 활용 가능
    //위에서 만든 it 활용
    it = vec.begin(); // 반복자 순번을 0으로 만들고

    it++;
    it++;
    it++; // 순번 +3, 4번째 숫자를 참조 중

    vec.insert(it, 444); // ← vec.begin() + n 대신 it 바로 사용 가능

    it++;
    it++;
    it++;
    it++;
    it++;
    it++; // 순번 +6, 7번째 숫자를 참조 중

    vec.emplace(it, 777);

    it = vec.begin(); // 반복자 순번을 0으로 만들고

    it++;
    it++;
    it++;
    it++;
    it++; // 순번+5, 6번째 숫자 참조 중

    vec.erase(it);

    // 출력
    for (vector<int>::iterator it2 = vec.begin(); it2 != vec.end(); it2++)
    {
        cout << *it2 << endl; // 이렇게도 벡터 출력 가능
    }

    // -----------------------------------------------------------------------

    // 사실, 벡터를 쓰는 동안은 반복자가 오히려 불편할 수도 있다

    // 쓰는 이유는 메모리 위치를 (정확히) 참조하기 위해서 하나뿐인데

    // 이런 경우를 코딩으로 시도해보자

    // it = vec.begin(); // 순번 0으로 맞추고
    // 
    // it++;
    // it++; // 순번 +2
    // 
    // vec.insert(it, 99999); // 삽입 한 번 해주고
    // 
    // it++;
    // it++;
    // it++; // 순번 +3
    // 
    // vec.insert(it, 99999);
    // 
    // vec.erase(it);
    // 
    // // 출력
    // for (vector<int>::iterator it2 = vec.begin(); it2 != vec.end(); it2++)
    // {
    //     cout << *it2 << endl; // 이렇게도 벡터 출력 가능
    // }

    // 위처럼 작성하면 코드상 문제가 없는데도 실행하면 앱이 중단된다
    // 왜?

    // 이유는 반복자의 특성과 벡터의 특성이 잘못 만났기 때문
    // 반복자 : 메모리 정보를 알기 위해서 만든, 벡터 혹은 동적 배열 밑의 클래스

    //그럼 반복자를 만들었을 때 = 벡터와, 그 순번의 메모리 위치가 등록이 될 것

    // 그런데

    // 벡터의 경우, 배열처럼 []를 쓸 수 있도록 하기 위해서
    // 내부 구성요소를 고의로 일직선 정렬을 시킨다는 특성이 있다

    // 그리고, 이 상태에서 추가로 구성요소가 더해질 경우
    // ** 벡터는 반드시, 혹은 가끔, 자기 자신을 복사한다

    // 특히 insert, emplace, erase가 실행되면 벡터의 특성상,
    // 그리고 오류를 막기 위한 C++의 자체 조치로 인해
    // 삽입, 삭제 이전에 할당된 반복자의 값은 무료화된다(반복자 무효화, iterator invalidation)

    // 그래서 벡터에서 사본이 만들어질 수 있는 함수들(push_back, pop_back, insert, emplace, erase, 아무튼 구성요소가 바뀌는 함수)
    // 이대로 실행한 뒤에는 반드시 반복자의 위치를 다시 지정해줘야 한다

    // 이를 반복자 재지정(재할당)이라고 한다

    it = vec.begin();

    it++;
    it++; // 순번 +2

    vec.insert(it, 12345); // 삽입 실행 후에 반복자가 무효화된다

    it = vec.begin(); // 이 코드는 단순이 순번 되돌리기만이 아니라 반복자의 유효성을 유지하기 위해서도 필요했던 것!

    it++;
    it++;
    it++;
    it++; // 순번 +4

    vec.emplace(it, 1357911); // 삽입 후에 반복자 무효화

    it = vec.begin(); // 다시 재지정(삽입, 삭제 후마다 계속 재지정 필요)

    it++; // 순번 +1

    vec.erase(it); // 삭제

    // 출력
    for (int i = 0; i < vec.size(); ++i)
    {
        cout << vec[i] << endl;
    }

    // it를 이렇게 벡터에서 사용할 때는 메모리 위치의 무효화에 항상 주의를 기울여야 한다

    // 그렇지 못할 때, 삽입 삭제 후에 (즉 사본의 생성 후에)잘못된 메모리 주소를 찾아간다
    // 그곳의 데이터를 읽으려도 앱이 다운될 수 있다 → 벡터 터진다

    // + []가 그럼 무조건 안전한가? 꼭 그렇지만도 않다
    //   []는 결국 포인터의 연산자 = 벡터의 순번을 무시하고 그냥 무조건 그 메모리 위치를 참조
    //   = (지금은 아니지만) 먼 옛날 버전 C++에서 잘못 썼다가, 벡터에서 지운 중간 위치를 참조하러 갈 수도 있다
    //   → 똑같이 []도 무효화된 반복자처럼 데이터를 읽으려다 ...→ 벡터 터진다

    // 가장 좋은 것 :
    // 1. C++은 언제나 요즘 거 쓰세요("물건은 무조건 새거 쓰세요")
    // 2. 반복자를 쓴다면 삽입, 삭제 후에는 반복자 재지정을 잊지 마세요(반복자 무효화는 C++의 법칙입니다)

    // ---------------------------------------------------------------

    // 반복자에 대해 추가 팁
    // 1. begin과 end의 정확한 위치는 어디인가? 
    // → 구성요소가 기준이 아니다. "벡터라는 클래스 자체가 완전히 시작하고 끝나는 위치"이다
    // → 따라서 end();가 호출되었을 경우, 이 위치에서는 읽을 수 있는 구성요소가 없다

    // 그래서 벡터 vec의 미자막 구성요소를 보고 싶다면 : (vec.end() - 1)을 불러야 한다
    
    // 2. 왜 이렇게 복잡하고 어렵고 더러운 기능을 벡터에 주었느냐?
    // → 사실 반복자가 벡터 혼자 쓰려고 만든 게 아니다
    // → 동적 배열이 벡터만 있는것도 아니다
    // → 원래는 다른 동적 배열에 쓰려고 만들었다가, 벡터에도 적용이 된 것뿐

    // 3. 그럼 반복자가 필요할(유용할) 정도의  다른 동적배열이 또 있는가?
    // → 벡터 외에 list라는 동적 배열이 게임 개발에서 같이 자주 쓰인다 \
    // → deque라는 것도 있다
    // → 동적 "배열"은 아니지만 pair, map등 다른 자료를 집합화하는
    //    다른 자료 구조도 많다
    // → 그리고 이 모두에서 반복자는 일부에서는 유용하다
    //    + 어쨌든 한 클래스에서 반복자를 익히면 다른 클래스에서도 똑같이 쓸 수 있다
}