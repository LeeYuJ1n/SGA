#include <iostream>

using namespace std;

// 2965번 문제, 인접화 요약
// 1. 서로 다른 세 자연수가 주어진다 (간격은 최소 1 이상)
// 2. 더 가까운 바깥쪽 자연수가 더 큰 간격을 가진 두 수 사이로 들어간다
//    (1, 2, 5라면 1이 3, 4 중 한 군데로 들어간다)
// 3. 2의 과정을 반복해서 인접시킨다
// 3-1. (이번 문제의 다른 조건) 인접화에 걸리는 "최대" 횟수를 구하자
//      (보통은 인접화 그 자체가 목적이거나, 최소 횟수를 구하는 경우도 있는데)
//      (이 경우 모두 접근법이 약간씩 다르다는 점에 주의)

int main()
{
    // 필요한 변수 : 서로 다른 세 자연수, 서로 위치라는 관계로 엮였음
    // = 배열 쓰기 매우 좋다
    int arr[3];
    int count = 0;     // 그리고 인접화 계산을 한 횟수

    // 이 배열을 입력을 받자
    // * cin의 팁 : cout처럼 연속해서 입력을 받을 수 있다
    //              연속 입력을 받을 경우, 공백으로 값을 구분해줄 수 있다
    cin >> arr[0] >> arr[1] >> arr[2];            // 1 2 5 등으로 띄워 가면서 세 정수 입력 가능

    // 시험출력 ( * 코딩 테스트 상황이면 이런 부가 출력은 불가)
    cout << arr[0] << " " << arr[1] << " " << arr[2] << endl;


    // 인접이 될 때까지 돌려봅시다
    // 무한반복문 돌리기 가장 좋은 조건
    // 이 반복문이 돌기 위한 조건 : 인접이 아닐 때
    // 1번과 2번, 2번과 3번 숫자의 차이가 1보다 클 때 (차이가 1이면 인접)
    while (arr[1] - arr[0] > 1 || arr[2] - arr[1] > 1)
    {
        // 반복문이 한 번이라도 실행됐다면 인접화 필요가 있다 (수행한다)는 뜻
        count++;         // 계산 횟수 +1

        // 어느 쪽 자연수가 "중간"에 더 가까운가?
        if (arr[1] - arr[0] < arr[2] - arr[1])          // 1번과 2번의 차이가 더 작을 때 : 가장 작은 숫자가 더 중간에 가까울 때
        {
            // 방법 1. 1번째 숫자를 뒤의 두 숫자 사이에 넣고, 순서를 바꾸기
            // 방법 2. 1번째 숫자를 2번째 숫자로 수정하고, 2번째 숫자를 2, 3번째 숫자 사이의 값으로 넣기
            // 여기서는 방법 2를 선택

            // 여기서 조건 환기 : 최대 횟수 구하기 = 최대한 인접을 지연시켜서 진행
            // → 두 수의 사이로 갈 때, 최대한 바깥쪽으로 가서, 남은 간격을 크게 유지
            // → 가장 큰 수의 직전으로 갈 때 가장 인접화가 지연
            arr[0] = arr[1];
            arr[1] = arr[2] - 1;            // 가장 큰 수의 직전
        }
        else
        {
            // 1번과 2번의 차이가 더 크거나, 차이가 없을 때
            // 반대로 뒤에 있는 숫자가 앞의 두 수 사이로 들어온다
            // 위와 마찬가지로, 인접을 지연시키기 위해서, 사이로 들어오는 숫자는
            // 가장 작은 수의 직후로 들어갈 때 가장 인접화가 지연
            arr[2] = arr[1];
            arr[1] = arr[0] + 1;            // 가장 작은 수의 직후
        }

        // 시험 출력
        cout << arr[0] << " " << arr[1] << " " << arr[2] << endl;
    }

    // 인접화 완료
    // 결과 출력
    cout << count;
}