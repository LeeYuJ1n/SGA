#include <iostream> // 이게 전처리기
#include <string.h> // 문자열 로딩
#include <vector>   // 벡터 로딩

// include : 가장 많이 쓰이는 전처리기 명령어
//           → C++ 코딩을 쓰거나 읽기 전에, 필요한 기능을 미리 불러오는 역할
//           → 컴퓨터 입장에서는 해당 기능의 코드를 이곳에 추가하는 것이나 마찬가지
//           → include 뒤에 <>혹은 ""를 써서 필요한 기능을 불러오는데
//           → <>는 C++, 혹은 비주얼 스튜디오 (혹은 그 때 사용 중인 에디터) 등에 포함된 기본 기능
//           → ""는 개발자가 직접 만든 다른 모든 기능을 뜻한다

#include <algorithm> // ← "알고리즘"이라는 이름의, C++ (혹은 C) 기본 기능을 부른다는 뜻
                     // #include "클래스.h" ← 내가 만든 "클래스" 클래스를 부르겠다는 뜻

// define : 대중적으로 쓰이는 중요한 전처리기 명령어
//          → 현재 파일, 혹은 이 파일의 내용이 불러와지는 모든 프로젝트 코딩 내에서
//          → define 뒤에 오는 텍스트를 특정한 경우로 인식하겠다는 뜻

#define GOO 9           // ← GOO라는 단어가 지금부터 나오면 9라는 숫자로 인식하겠다는 뜻
#define MYNAME "도화가" // ← MANAME이라는 단어를 특정 문자열로 인식하겠다는 뜻
#define THISISONE      // ← (뒤에 치환할 값이 없는 경우) 지금부터 모든 코드를 THISISONE이라는 의미로 받아들이겠다는 뜻

// define을 쓸 때, 필수는 아니지만 보통은 define 후의 단어를 전부 대문자로 자주 표기
// → define된 텍스트라는 의미를 확실히 해두고 싶어서 (헷갈리기 싫어서)
// 이렇게 define으로 만들어진 대체 텍스트들을 "매크로"라고 한다
// C++에서 매크로라는 단어가 나오면, 바로 이 define 코드를 지칭

// define의 다른 사용 예
#define ARRAY_SIZE 10

using namespace std;

int main()
{
    // 오늘의 주제 : 코드에 이름 다시 붙이기
    // 1. 전처리기 (Processor, 사전 처리 절차 : 코드가 컴파일되기 전에, 에디터 차원에서 먼저 처리해주는 코드)
    // 2. 사용자 재정의 자료형 (사용자가 자료형에 이름을 다시 붙이는 코드)
    // 3. 열거형 (사용자가 값에 이름을 따로 붙여서 열거한 목록)

    // ---------------------------------------------------

    // 1. 전처리기 : 코드가 컴파일되기 전에, 에디터 차원에서 먼저 처리해주는 코드
    //              → 제일 먼저 실행되는, 별도의 프로그래밍
    //              → 일반적으로 코딩에 바로 쓰이진 않고 코딩의 규칙을 미리 정하는 역할 주로 한다
    //              → 작성 방법 : 함수 밖에서 #을 입력하고 명령어 입력 후, 줄을 바꾸어서 종료

    // 작성 예 : main 함수 위에서 #으로 작성
    // ** 위에 적은 define 전처리기를 테스트
    cout << GOO << endl;
    cout << MYNAME << endl;

    // 위 코드의 값 : 9, 도화가
    // 코딩은 GOO, MYNAME으로 했지만, 컴퓨터는 이 텍스트를 컴파일하면서
    // 미리 9라는 숫자와 도화가라는 문자열로 바꾼 것
    // 그래서 실제 실행은 9와 문자열을 출력한 것과 똑같이 된 것

    // **define THISISONE 테스트
    // 하는 겸, 하나 더 전처리기 명령어

    // 전처리기에도 조건문을 쓸 수 있다
    // 그냥 조건문과 차이 : 전처리기 if는 거기에 해당이 안 되면  아예 컴파일을 안 한다
    // → 용량 아끼기 좋고, 반면 아주 명확한 경우의 수를 제시하지 못하면 오류 나기도 좋다
    // → 특정 하드웨어 상황, 혹은 특정한 태그 하에서만 작동하는 코드를 쓰려고 할 때
    //   전처리기 조건문을 쓰면 매우 유용하다

#ifdef THISISONE 
    //ifdef : "if"와 "def"가 같이 쓰인 것. 의미는 "이 매크로가 정의되어 있다면"
    // → 다시 말해 이 모든 코드의 이름이 THISISONE이라면
    // → 그러면 아래 코드가 활성화
    cout << "이 코드의 태그를 확인했습니다" << endl;

#else
    // 전처리기의 조건문에 해당되지 않은 경우, 코드가 아예 컴파일도 되지 않는다
    cout << "이 코드의 태그가 없는 것을 확인했습니다" << endl;

#endif
    // 이런 식으로 매크로에 따라 컴파일이 되거나 되지 않는 것을 "선택적 컴파일"이라고 한다
    
    // 선택적 컴파일을 할 때 유용한 상황
    // 1. 디버깅 전용 코드 (디버그 상황일 때만 로그를 출력하고 싶다면)
    //    → main위에 #define DEBUG 이런 식으로 한 줄 붙이기
    // 2. 윈도우 전용 코드 / 안드로이드 전용 코드 / 아이폰 전용 코드
    //    → 등을 같이 만들어야 하지만, 용량을 줄이고 싶을 때

    // 선택적 컴파일을 할 때 주의할 점 (중에서 실전에 해당하는 한 가지)
    // → {} 걸치지 말 것 : #if 시작전에 {를 시작하고, #endif 나오기 전에 }를 닫지 말라는 뜻

    // 전처리기(#)에는 이것 말고도 더 많은 기능이 있지만 현재, 혹은 게임 환경에서 꼭 알아야 하는 부분은 여기까지
    // 다만 #으로 컴파일 이전 단계에서 코딩을 할 수 있다는 점만은 꼭 기억해둡시다

    int arr[ARRAY_SIZE]; // ← 매크로를 이용한 배열 선언
                         // 나중에 배열 크기 바꾸고 싶으면 매크로가서 바꾸면 된다

    // -----------------------------------------------------

    // 사용자 재정의 자료형 : "사용자 정의 자료형"의 한 종류
    // 구조체가 여러 개의 자료형 (그리고 변수)들을 묶어서 하나의 이름으로 불렀다면
    // 사용자 재정의 자료형은 반대로 하나의 원래 정해진 자료형을 다른 이름으로 재명명

    // 작성예 (작성 위치는 아무데서나 해도 되지만, 변수의 지역 위계, 범위성을 따른다)
    //        → 전역 변수 위치에 재정의가 되면 아무데서나 이름 사용 가능
    //        → 지역 변수 위치에 재정의가 되면, 그 지역 변수의 범위에서만 사용 가능

    // 재정의 명령어는 : typedef
    typedef int JUNGSOO;  // int라는 원래 있는 자료형을 "정수"라는 이름으로 재명명
    typedef float SILSOO; // float이라는 부동 소수를 "실수"라는 이름으로 명명

    // 명명된 자료형으로 변수를 만들기
    JUNGSOO a = 100;   // "정수" 100 만들기
    SILSOO f = 99.78f; // "실수" 99.78

    cout << a << endl;
    cout << f << endl;

    // 재정의에서 쓰이는 명명은 개발자 마음이라서 아무렇게나 해도 된다
    // 다만 의미 면에서 크게 벗어나지 않는 편이 덜 헷갈릴 것

    typedef int SOSOO;    // "소수"라는 이름으로 소수 자료형 재정의
    SOSOO sosoo = 100.8f; // 0.8 무시된다

    cout << sosoo << endl;
    // int를 재명명할 때 소수라고 부르든 말든 아무 문제가 없지만
    // 그렇게 만들어진 "소수"를 잘못 쓰면 의도한 결과가 나오지 않을 수도

    // 사용자 재정의 자료형도 매크로처럼 대문자로 작성되는 경우가 흔하다
    // → 덜 헷갈리고, 기존의 코드와도 덜 겹칠 테니까

    // 사용자 재정의 자료형을 응용하면 아래 같은 코드도 사용 가능 (큰 의미는 없지만)
    typedef struct
    {
        // int x = 1;
        // int y = 1;
        // int z = 1;
    } NORMAL;
    // 위 코드 : 이름 없는 구조체를 먼저 만들고 → 그 구조체의 이름을 NORMAL로 재명명한 코드
    // 이 경우 이름 없는 구조체는 멤버 변수를 완전한 형태로는 선언할 수 없다 (주의)

    // typedef의 다른 (그리고 개인 코딩에서 매우 쓸모 있는) 활용법
    typedef string STRING;
    typedef vector<int> INTVEC;

    // 이런 식으로 C++ 지원 클래스 방식 자료형을 재정의하고
    STRING str;
    INTVEC intvec;

    // 이렇게 재정의된 이름으로 편하게 (using std 없이) 코딩 가능

    // ---------------------------------------------

    // 열거형 (enumenaration)
    // 특정한 값을 다른 이름으로 재정의하고 목록화한 것

    // 작성법 : enum을 사용
    enum Color
    {
        RED,
        GREEN,
        BLUE,
        MAGEMTA,
        YELLOW,
        CYAN,
    };

    // Color라는 구분 아래, 6개의 값이 각각 이름을 부여받고 지정

    // Color를 사용해서 변수를 만들 수도
    Color color = RED; // 빨간색
    
    cout << endl;
    cout << color << endl; // 0이 출력된다
                           // → 0이라는 숫자에 RED라는 이름을 붙인 것이 바로 열거형 Color의 정체

    Color color2 = (Color)3; // ← 3이라는 정수를 Color로 재지정해서 할당
    cout << color2 << endl;  // 3 출력

    //color++; ← C++에서는 안 되지만, 이후의 언어에서는 통하는 코드
    // 열거형 자체를 마치 숫자인 것처럼 계산한 수도 있다 (나중에는)

    // 다른 열거형도 만들어서 쓸 수 있다
    // 열거형을 여러 개 쓸 때는 열거형의 값으로 같은 단어가 중복되지 않도록 해야한다
    // 해결 방방 1. 클래스, 혹은 (나중 단계로서) 네임스페이스를 모두 다르게 만들기
    //              → 효율적인 방법은 아니다
    //           2. 눈 가리고 아웅인 방법이지만, 오히려 효율적
    //              → 열거형의 값 앞에 열거형 목록의 이름을 하나 더 붙여주는 것
    
    // 예 : COLOR_RED, COLOR_BLUE, COLOR_HAPPY, FELL_BLUE... 이렇게 중복 방지
    //      중복만 방지되는 게 아니라 쓰는 입장에서도 알아보기 쉽다는 장점이 있다

    enum Feel
    {
        HAPPY,
        SAD,
        ANGRY,
        BORED,
        EXCITING,
        // BLUE, ← 진짜 오류
    };

    // Feel feel = BLUE; ← 오류의 확인

    // ----------------------------------------------------------------

    // 열거형, enum을 언제, 왜 쓰는가? : 값 자체에 이름을 부여해서 개발 중에 이해를 쉽도록 하기 위해서
    // 특히 그 값이 특정 상태(state)를 뜻하는 코드일 때 열거형은 더욱 유용

    // 예시를 코드로들기
    enum NPC_STATE // 게임 등장인물의 상태
    {
        RESERVED, // 대기, 예약 상태 : 아직 안 나왔음
        STANDBY,  // 막 나옴 : 아직 행동 안 함
        IDLE,     // 가만히 있음
        BATTLE,   // 싸우는 중임
        EAT,      // 식사 중임
        DEAD,     // 죽었음
        DESTROY   // 파괴됨 (게임에서 지워질 예정)
    };

    // 이렇게 만들어두면 npc를 게임에서 조작할 때 이름으로 상태를 편하게 제어

    enum PLAYER_CLASS // 플레이어 캐릭터의 직업
    {
        WARRIOR,
        PRIEST,
        ROGUE,
        WIZARD,
        MONK,
        DEATH_KNIGHT,
        WARLOCK,
        PALADIN,
        DEMON_HUNTER,
        NOROO,
        SHAMAN,
    };

    enum GAME_STATE // 게임의 현재 상태
    {
        START,
        PLAY,
        PAUSE,
        GAMEOVER,
    };
    // 이 처럼 코드를 미리 만들어 두었다가, 코딩에서 int gamestate같은 변수 대신
    // GAME_STATE 같은 열거형을 이용한 변수를 만들어서, 필요할 때 수정 가능

    // ----------------------------------------------------------------

    // 열거형의 다른 사용 방법 : 임의 수치 부여
    enum SUTJA // 숫자라는 이름의 열거형
    {
        SAM = 3, // ← SAM은 3이라고 의미를 추가로 부여
        SA,
        O,
        YUK
        // 3, 4, 5, 6 이라는 값 만들기
    };

    // 열거형 값에 수를 부여한 것과 하지 않은 것의 차이

    GAME_STATE state = START;       // 첫 번째 열거형 값
    PLAYER_CLASS pcClass = WARRIOR; // 첫 열거형 값
    SUTJA number = SAM;             // 첫 열거형 값

    // 셋 다 자기 열거형 목록에서 맨 처음 값
    // 현재 변수를 출력

    cout << endl;
    cout << state << endl;     // 0으로 출력
    cout << pcClass << endl;
    cout << number << endl;    // 3으로 출력

    // 열거형 작성 시에 임의로 수를 값에 부여하면, 그 값으로 의미가 바뀐다

    // pc직업과 숫자 변수를 셋씩 만들어서 각 목록의 1, 2, 3 번째 값을 할당
    PLAYER_CLASS pcClass1 = WARRIOR;
    PLAYER_CLASS pcClass2 = PRIEST;
    PLAYER_CLASS pcClass3 = ROGUE;

    SUTJA number1 = SAM;
    SUTJA number2 = SA;
    SUTJA number3 = O;

    // 출력
    cout << endl;
    cout << pcClass1 << endl; // 0
    cout << pcClass2 << endl; // 1
    cout << pcClass3 << endl; // 2

    cout << endl;
    cout << number1 << endl; // 3
    cout << number2 << endl; // 4
    cout << number3 << endl; // 5

    // 여기서 열거형 값의 특성 3가지를 이해할 수 있다
    // 1. 열거형의 값은 제일 위, 첫 번째 값을 기준으로 한 차례 뒤로 갈 때마다
    //    수의 값이 +1 된다 (0, 1, 2, 3 순으로 올라간다)
    // 2. 열거형 목록의 첫 번째 값은 따로 입력하지 않으면 0이다
    // 3. 열거형 목록의 첫 번째 값을 임의로 입력해주면 해당 값이 된다
    //    그리고 그 다음 값들은 다시 수정된 첫 번째 값을 기준으로 올라간다
    //    (첫 번째 값이 3이면 다른 값은 4, 다음은 5, 6, 7...)

    // -------------------------------------------------------

    // 실습

    // 열거형 작성
    enum SPECIALIST
    {
        // 스페셜리스트 직업 및 서머너
        ARTIST = 10,     // ARTIST에 임의로 10 할당
        WEATHER,
        SUMMONER,
    };

    // 값 할당
    SPECIALIST pcClassNull1 = ARTIST;     // 10 할당
    SPECIALIST pcClassNull2 = WEATHER;    // 11 할당
    SPECIALIST pcClassNull3 = SUMMONER;   // 12 할당
    cout << endl;                         // 줄 바꿈

    // 출력
    cout << pcClassNull1 << endl;  // 10 출력
    cout << pcClassNull2 << endl;  // 11 출력
    cout << pcClassNull3 << endl;  // 12 출력
    cout << endl;                  // 줄 바꿈

    // ------------------------------------------------------
}