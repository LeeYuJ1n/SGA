#pragma once

class LoadingScene : public Scene
{
public:
    LoadingScene();
    ~LoadingScene();

    void Update();
    void Render();
    void PostRender();
    void Init();
    void Quit();

    bool LoadComplete() { return ((timePassed / timeTotal) >= 1); }

private:

    //로딩을 위한 진행 상황 표시기 (진행 바)
    //Quad* progressBar;
    ProgressBar* progressBar;

    //여기서 진행 바를 쿼드(텍스처)로 만들면 -> 크기를 조절했을 때 양 옆으로 움직이게 된다
    // 이 때 크기를 조절했을 때 한쪽으로만 커지게 하는 방법

    // 1. 트랜스폼 내에서 축의 정보를 이용해서 행렬 연산에 보정치를 주기 (+정석인데 번잡한 코드)
    // 
    // 2. 비효율적이지만 직관적이고 다루기 쉬운 방법 : 1과 근본 원리는 같다
    //    -> 텍스처와 별도로 움직이는, 그러나 똑같이 붙어다닐 제 2의 트랜스폼을 하나 더 줘버리면 된다
    //    -> 텍스처를 자식으로 삼은 부모 트랜스폼을 만들면 된다
    //    -> 커스텀 UI의 탄생

    // 로딩이 끝나면 다음 씬으로 넘어가거나... 넘어가기 전에 안내가 떠서 알려주도록
    //Quad* pressStart; // 시작을 눌러주세요 그림
    Button* pressStart; //위 변수를 버튼으로 수정한 것

    //비행기 씬 시작하기
    void StartPlaneScene();

    //로딩을 흉내내기 위한 부가자료
    //로딩에 걸릴 시간과 현재의 시간

    float timePassed; // 현재 시간, 혹은 지나간 시간
    float timeTotal = 1; //총 시간, 로딩에 걸려야 할 시간

    //* 실제로 로딩이 되는 원리
    // (전부는 아니지만 대부분 이런 원리)
    // 로딩 씬을 들어가면, 다음 씬에서 읽어야 할 파일(데이터)의 목록이 주어진다
    // -> 이 목록을 다 읽고 나면 그 다음에 로딩 씬이 끝나고 다음 씬이 시작되는데....
    // -> 지금은 그 다음 씬에 로딩이 필요할 정도로 방대한 데이터가 없기 때문에
    // -> 그냥 로딩을 한다고 치고 진행 상황을 묘사

    // -> 실제로 로딩이 목록 읽기에 의해서 이루어졌을 경우, 로딩이 묘사되는 기준은
    // ----> 현재 읽어들인 데이터의 양 / 전체 데이터의 양

    // -> 그래서 흉내 씬의 경우에도 진행 바의 채워지는 기준은
    // -----> 현재 지나간 시간 / 총 시간
};

