#include <iostream>
#include <map>
#include <vector>

using namespace std;

// 일반 프록래밍이 적용된 함수들 (설명은 아래)

template <typename T>             // 덧셈
// float Add(T a, T b) ← 템플릿은 일반 자료형과도 쓸 수 있다
T Add(T a, T b)
{
    return a + b;
}

template <typename T>             // 뺄셈
// T Sub(T* a, T& b) ← 포인터 자료형과, (아직 정해지지 않은) 변수의 메모리 위치 참조 가능
T Sub(T a, T b)
{
    return a - b;
}

template <typename T>            // 나눗셈
T Div(T a, T b)
{
    return a / b;
}

template <typename T>            // 곱셈
T Mult(T a, T b)
{
    return a * b;
}

// 템플릿 사용 시, 임시 자료형을 두 개, 혹은 그 이상 사용 가능
//...pair, map 등에서 실제로 사용 사례 확인 가능
template <typename Type1, typename Type2>
Type2 TestMult(Type1 a, Type2 b)                           // Type1을 받아서 계산 후 Type2로 반환
{
    return (Type2)(a * b);                             // 확실하게 형변환
}

// 템플릿 사용 시, 명령어가 적용된 범위 (tamplate 직후 작성된 함수) 밖에서 지정된
// 또 다른 임시 자료형 (혹은 template의 선언 등)은 쓸 수 없다
// 다르게 말하면, template도 일종의 함수처럼 범위가 정해져 있고, 밖에서는 접근 불가능
// template으로 정한 임시 자료형의 명명, 연산의 효용 등은 그 template 안에서만 적용
template <typename T>
T TestDiv(T a, T b)
{
    if (b == 0)
    {
        return 0;
    }
    return a / b;
}

int main()
{
    // 코딩을 할 때, 새로운 형식들을 만나보게 되었다
    vector<float> f;                // ← 소수를 위한 vector
    map<int, char> icMap;           // ← 정수를 key로, 문자를 value로 쓰는 맵

    // 위 코드들은 자료형 자체에 진짜 어떤 자료를 다룰지에 대해서는 정해진 게 없다
    // 해당 코드에서 실제로 다룰 자료는 모두 <> 안에서 정의된다

    // 이런 식으로 <> 안에서 자료형이 지정되면 그때그때 해당 자료형으로 맞춤 실행되는,
    // 다른 말로는 특정 자료형을 지정하지 않고 코드의 원리만 정해져서 제공된 기능들을 → "일반 지원 기능"이라고 한다 (generic function)

    // 그리고 개발자도 이런 식으로 코딩할 수있다
    
    // 자료형을 미리 정하지 않고, 그때그때 사용할 때 자료형을 따로 지정할 수 있는
    // 원형만 만들어놓으면 쓸 때 호출해서 자료형을 매번 다르게 지정할 수 있는

    // ...그런 프로그래밍을 일반 프로그래밍이라고 한다 (generic programming)

    // ----------------------------------------------------------------------------------------------

    // 일반 프로그래밍 기법이 적용된 함수 작성 (위에)

    /* 설명을 위한 주석

    template <typename T>
    T Add(T a, T b)
    {
        return a + b;
    }

    위 함수 모양에서 쓰인 각 키워드의 의미
    1. template : 이 아랫줄에 쓰이는 함수는 일반 프로그래밍 방법으로 작성된다,
                  즉 정해진 자료형이 없을 것이라는 선언
                  여기 쓰인 명령어를 따서, "일반 함수"를 "템플릿 함수"라고도 한다

    2. <typename T> : 템플릿 함수라도 코딩 중에 "아무튼 자료형으로 취급해야 할 상황"은 생긴다
                      그 때, 아직 정해지지 않은 자료형"을 의미할 단어가 필요하다
                      그 단어는 개발자가 지정을 해야 하고, 그 지정에 쓰이는 명령어가
                      typename, 그리고 그 뒤에 오는 이름이 (여기서는 T인데, 정하기 나름)
                      임시 자료형이다 (일반적으로 T, Type 등의 표기가 자주 쓰인다)

    3. 그 아래부터 나오는 T : 윗줄에서 지정된 임시 자료형의 이름을 이용해서
                             이후 함수가 호출됐을 때, 지정받을 자료형을 어떻게 처리할 것인가
                             하는 부분을 나타내는 표시
                             (int로 함수를 호출하면 T는 int로 작동, float으로 호출하면 T는 float)

    이렇게 템플릿 명령어를 이용해서 함수를 만들게 되면...
    제약 : 함수를 호출할 때마다 자료형을 반드시 지정을 해줘야 하게 된다
    장점 : 논리관계나 연산을 위한 원형 함수만 만들어놓으면, 일일이 다른 함수를 만들 필요없이
           더 많은 자료형에 대응해서 연산을 수행할 수 있게 된다 ( 함수 오버로드 필요없이 한 번만 작성)
    */

    // 함수 사용
    
    cout << "덧셈1" << endl;
    cout << Add<int>(3.3f, 7) << endl;

    cout << "덧셈2" << endl;
    cout << Add<float>(99.9f, 13.7f) << endl;

    cout << "곱셈" << endl;
    cout << TestMult<int, float>(3, 7.7f) << endl;

    cout << "나눗셈" << endl;
    cout << TestDiv<int>(3, 7) << endl;
    
    cout << endl;              // 줄 바꿈

    // cout << Add(3.3f, 7) << endl; ← 템플릿 사용 시 사용 불가능

    // ------------------------------------------------------------------------

    // 실습 : 직접 해봅시다!

    // 템플릿을 이용한 사칙연산 만들기

    cout << Add<int>(10, 10) << endl;                 // 정수 덧셈
    cout << Add<float>(10.10f, 1.1f) << endl;         // 소수 덧셈

    cout << Sub<int>(10, 5) << endl;                  // 정수 뺄셈
    cout << Sub<float>(2.4f, 10.12f) << endl;         // 소수 뺼셈

    cout << Div<int>(10, 2) << endl;                  // 정수 나눗셈
    cout << Div<float>(23.6f, 102.1f) << endl;        // 소수 나눗셈

    cout << Mult<int>(10, 10) << endl;                // 정수 곱셈
    cout << Mult<float>(10.3f, 123.4l) << endl;       // 소수 곱셈

    // ------------------------------------------------------------------------

    // 템플릿을 쓰면 좋은 이유, 쓰는 이유

    // : 매개변수가 달라질 수 있기 때문
    // : 경우에 따라 함수의 목적이 달라질 수 있기 때문

    // → 똑같이 두 수를 더하는 게 연산인 함수인데
    //   그래서 결과 그 자체가 필요하냐, 아니면 나온 결과를 출력하는 게 필요하냐
    //   (예 : 게임에서 주인공의 생명력을 순수하게 계산할 때와, 계산된 수치를 출력할 때)
    //   이럴 때 자료형에 변화를 줘서 계산을 다르게 이끌어낼 수 있다

    // 또 다른 이유 : (게임 외 앱, 네트워크 등에서) 정확히 어디서 어떤 자료가 와야 되는지 모를 때
    //                데이터베이스 관리 프로그램인데 A게임도 관리하고 B게임도 관리한다면?
    //                A게임 캐릭터용 함수 따로 B용 함수 따로...이러면 유지보수가 안 된다!
    //                그럴 때 템플릿을 함수를 쓰면 A에도 쓰고 B에도 쓸 수 있는 함수 하나만 만들 수 있다!

    // 템플릿에서 추가로 할 수 있는 변형들

    // -----------------------------------------------------------------------

    // 실습 2 : 더 많은, 더 바뀐 템플릿 자료형을 적용해봅시다

    int x;
    int y;
    int result;

    // 위 변수에 임으의 값을 각각 주거나 자료형을 바꿔가면서

    // 1. 사직연산 계산 후 result에 결과를 저장도 해봅시다
    // 2. 소수, 실수 등으로 사칙연산 및 나머지 도출도 한번 실험해봅시다
    // 3. 오늘의 도전 겸 내일의 강의 겸 예습(과제) → "과제" 메모장 참고
}