#include <iostream>

int main()
{
    // ------------포인트와, 우리가 사용했던 배열의 좀 더 자세한 관계

    // 예시용 배열
    int arr[10] { 1, 2, 3, 4, 10, 9, 8, 7, 6, 5};

    // 포인터
    int* ptr;

    // 배열 출력(배열의 일반적 사용)
    std::cout << arr[0] << std::endl; // 첫 번째 위치 = 0번 = 값은 1
    std::cout << arr[1] << std::endl;
    std::cout << arr[2] << std::endl;
    std::cout << arr[3] << std::endl;
    std::cout << arr[4] << std::endl; // 5번째 위치, 4번 순번, 값은 10
    std::cout << arr[5] << std::endl;
    std::cout << arr[6] << std::endl;
    std::cout << arr[7] << std::endl;
    std::cout << arr[8] << std::endl;
    std::cout << arr[9] << std::endl;

    // 특정 위치만 뽑고 싶을 때는 그 위치만 뽑아서 써도 된다(당연한 추측)
    std::cout << arr[4] << std::endl; // 10보고 싶을 때는 4번 순번만

    // 배열의 메모리 주소를 출력
    std::cout << arr << std::endl; // 배열의 이름은 메모리 주소

    // 포인터를 통한 메모리 주소 할당
    ptr = arr; // 정수의 포인터에는 배열의 이름도 쓸 수 있다(배열이 곧 포인터니까)

    // 포인터 출력
    std::cout << ptr << std::endl;

    // 여기서 내가 포인터를 1을 더하게 되면 무슨 일이 일어날까?
    std::cout << ptr + 1 << std::endl; // 위에 있는 ptr에서 4가 더해진 메모리 주소가 나온다
    // → int를 처음에 지정한 포인터는 자신의 메모리 주소가 정수에 대한 것이라고 미리 판단하기 때문에
    // +1을 해주면, 원래의 메모리 주소에서 "정수 하나가 더 들어갈 만큼의 뒷자리"를 계산해서 보여준다

    // 그러면, 내가 포인터에 1을 더하고, 거기서 값을 호출하면 어떻게 될까?
    // 변수명앞에 * : 포인터(그 메모리 주소)에 있던 데이터를 호출

    std::cout << *ptr + 4 << std::endl; // 포인터에 4를 더하고 호출하면?

    // 위 코드의 값은 5, 명백히 내가 적지 않은 데이터가 도출 = 원하지 않은 결과
    // 이 결과의, 짐작 가능한 도출 이유 : ptr의 값인 1을 먼저 내놓고, 그 다음에 4를 더하기한 결과

    // 이런 일이 일어난 기계적인 이유 : +가 연산되기 전에 *부터 연산됐기 때문(연산자 간 우선순위)
    // 좀 더 개발 과정에 집중한 이유 : 연산식과 포인터가 같이 쓰였을 떄, 어느 범위까지가 포인터인 걸로 할지
    // 개발자(그리고 그 개발자가 개발한 컴퓨터 언어)가 정확하게 미리 생각을 못 했기 때문(그래서 연산자 우선순위를 원칙으로 세운 것)

    // 이런 경우, 우리가 원하는 결과를 얻기 위해서 취할 수 있는 조치가 : 바로 연산자 우선순위 변경, 기호로는 ()

    std::cout << ptr + 4 << std::endl; // ptr이 있는 곳에서 4x4 = 16(16진수 식으로 표현하면 10)이 더해진 메모리 주소가 나온다
    std::cout << *(ptr + 4) << std::endl; // ptr + 4를 하나의 범위로 지정 (괄호로 지정) → 앞에 *  붙이기

    // 결론 : 포인터에 4를 더하고 호출하면? 원래 있던 메모리 주소에서 4개의 숫자만큼 더 뒤로 간 위치...의 숫자를 불러온다

    // 그런데 ptr = arr. ptr의 값을 호출하면, arr에 있던 첫 번째 숫자가 호출
    // ptr + 4라는 건, arr의 5번째 숫자(다시 말해 4번째 순번)를 지칭하는 것

    std::cout << std::endl;

    // 확인을 위한 포인터 출력
    std::cout << *(ptr) << std::endl; // *(ptr + 0)하고 똑같은 의미
    std::cout << *(ptr + 1) << std::endl;
    std::cout << *(ptr + 2) << std::endl;
    std::cout << *(ptr + 3) << std::endl;
    std::cout << *(ptr + 4) << std::endl;
    std::cout << *(ptr + 5) << std::endl;
    std::cout << *(ptr + 6) << std::endl;
    std::cout << *(ptr + 7) << std::endl;
    std::cout << *(ptr + 8) << std::endl;
    std::cout << *(ptr + 9) << std::endl;

    // 결론 2 : 포인터에 + 숫자를 하는 것과, 배열에서 []안에 숫자를 넣는 것은 값 호출에서 기능이 똑같다

    // [] : 인덱스 연산자, 그리고 포인터에서 메모리 주소가 얼마나 떨어져 있는지를 나타내는 포인터의 연장
    // 더 정확하게 말하면 : 배열 그 자체가 사실은 브레이크를 걸고 쉽게 만들어진 포인터

    // ---------직접 실험해보기

    // char, float, double, long long, short 등 이전에 배웠거나 보고 넘어갔던 자료형...
    // ...이들을 활용한 배열도 한번 만들어서 써봅시다

    // 단, char는 c+에서 취급이 예외라는 점
    
    // 단 원소 하나하나 값을 호출할 때는 char도 값을 출력은 해줍니다
    // 그 부분을 확인하기 위한(외국인 전용 팁) : 문자열을 영어로 만들어서 써봅시다(c++에서는 한국인이 외국인)

    char name[9] ="computer";
    char* namePtr = name;
    std::cout << namePtr << std::endl; // 포인터 쓰면 아무튼 값은 출력
    std::cout << namePtr + 1 << std::endl; // 주소를 1자리 뒤로 옮긴 후 값을 출력 = 문자열 출력
    std::cout << name[2] << std::endl; // 배열의 3번째 글자를 출력(이렇게 c++에서는 문자열만 미묘하게 특별취급)

    // ---------------------------------

    // 포인터의 포인터

    int a = 0; // 이건 정수 변수
    std::cout << &a << std::endl; // 이건 a의 주소

    int* ptr1 = &a; // 이건 포인터
    std::cout << ptr1 << std::endl; // 이것도 포인터(a의 주소)

    // 그런데... ptr도 따지고 보면 작성된 "변수"니까
    std::cout << &ptr1 << std::endl; // 이건 포인터의 주소(a의 주소의 주소)

    // 그리고...
    // (int*)*ptrr = &ptr; // 이렇게 (포인터)*로 작성하면 오류. 그 대신

    int** ptrr = &ptr1; // ()그냥 떼버리고 *를 연속 두 개 쓰면 : 코드가 작성된다

    // 이렇게 만든 int**은 포인터의 주소를 값으로 받는, 포인터의 포인터가 된다

    std::cout << ptrr << std::endl; // ptrr의 값 : 포인터의 주소(a의 주소의 주소)

    // 위 과정을 통해 알아볼 수 있는 결론

    // 포인터도 변수다. 그러므로 포인터에도 주소가있다
    // 포인터의 주소도 값으로 취급해서 변수로 하나 더 만들 수 있다

    // 포인터의 포인터는 자료형**로 나타낸다 : 다중 포인터
    // 영어로는 이중 포인터(double pointer)

    // → 더 나아가면...포인터의 포인터도 변수로 만들면, 또 주소가 있지 않을까? → 있다
    // 그 포인터의 포인터의 주소를 사용한, 포인터의 포인터의 포인터도... → 가능

    std::cout << &ptrr << std::endl; // 포인터의 포인터의 주소

    int*** ptrrr = &ptrr; // 포인터의 포인터의 포인터

    std::cout << ptrrr << std::endl;

    // 이런 식으로, 꼬리의 꼬리를 물고, 주소를 추적하거나, 주소를 덧씌워 가면서,
    // 포인터는 이 뒤로도 마음만 먹으면 계속해서 중첩할 수 있다 : 그래서 다중 포인터

    // 그러나 다중 포인터에도 어느 정도 현실적인 한계는 있다

    // 1. 인간의 귀찮음 : 생각해봅시다, 포인터의 포인터의 포인터의 포인터의 포인터의 포인터의...

    // 2. 컴퓨터의 앞선 추측 : "포인터에 또 포인터를 쓴다면, 이 사람은 데이터를 배열로 관리할 가능성도 있다"고 해서
    //                        포인터 바로 뒤가 아니라 좀 떨어진 곳에 주소를 할당. 그런데 포인터 중첩이 너무 지나치면
    //                        메모리가 감당하지 못하거나, 혹은 기존 자료 사이에 새 변수를 만들 가능성

    // 이런 이유 때문에, 현실적으로 포인터는 극단적으로 길어도 4중 정도에서 끝나는 경우가 흔하다
    // 사실 2~3중 포인터가 제일 많다

    // ---------------------------------------------

    // 그러면, 2중 포인터는 왜 쓰는가? 언제 쓰는가?

    // 포인터를 쓴다는 것 : 크게 두 가지 의미가 있다

    // 1. 메모리 주소에 접근하겠다 : 데이터를 직접 조작(앞선 시간에 우리가 배웠던 것)
    // 2. 메모리 주소를 거쳐서 변수들을 관리하겠다 : 배열 쓰겠다(지금 우리가 위에서 본 것) 배열이 곧 포인터이기도 하다

    // 포인터의 포인터를 쓴다는 것은 곧... (메모리 주소를 개발자가 수동으로 일일이 조작할 수는 없다)

    // 메모리 주소를 거쳐서 포인터들을 관리하겠다 : 배열로 배열을 만들겠다

    // 배열로 배열을 만든다는 것(포인터를 사용했을 때)

    int arr1[3] = {1, 2, 3}; // 배열
    int arr2[3] = {4, 5, 6}; // 이것도 배열
    int arrx[5] = {7, 8, 9, 10, 11};
    int arrx1[3] = {15, 16, 17};

    // 그리고 배열은 포인터
    int* exm = arr1; // ← 포인터
    
    //  그러면... 이 포인터들을 배열로 만드는 경우는?

    int* arr3[4] = {arr1, arr2, arrx, arrx1}; // 배열인데, 배열에 들어갈 구성요소(원소)가 포인터인 경우

    int** exmm = arr3; // ← 포인터의 포인터

    // 위의 arr3 배열을 출력한다면?
    std::cout << std::endl; // 줄 띄워서 보기 쉽게 하고
    std::cout << arr3[0] << std::endl;
    std::cout << arr3[1] << std::endl;

    std::cout << std::endl;
    std::cout << arr3[0] << std::endl; // 이게 arr1의 이름 = 메모리 주소니까
    std::cout << *(arr3[0]) << std::endl; // arr이 있는 곳의 정수 = arr 배열의 0번째 순번
    std::cout << *(arr3[0] + 1) << std::endl;
    std::cout << *(arr3[0] + 2) << std::endl;

    std::cout << arr3[1] << std::endl; // arr2의 이름 = 메모리 주소
    std::cout << arr3[1][0] << std::endl; // arr3[1]이 곧 arr2니까, 이 뒤에 또 [0]을 붙이면 arr[0]
    std::cout << arr3[1][1] << std::endl;
    std::cout << arr3[1][2] << std::endl; // 이렇게 배열 속 배열을 불러온 후 뒤에 []를 붙여도 출력에 문제 없음
    std::cout << arr3[2][0] << std::endl;
    std::cout << arr3[3][1] << std::endl;

    // 그런데 위 코드에서 포이너에 + 숫자 하는 거나, [순번] 넣는 것 = 배열 조작
    // 그리고 []가 두 번 쓰였다..... : 다중 배열

    // 다시 말해서, 배열들이 있을 때, 그 배열을 가지고 다시 추가 다중 배열을 만들겠다면, 다중 포인터가 유용

    // 거기서 덧붙여서, 다중 배열을 만들려는데 구성요소들이 서로 배열 크기가 다르다면?
    // 즉 원소 하나하나를 별도로 만들어서 배열로 다시 묶어야 한다면?
    // 혹은... 다중 배열을 만들려면, 그 배열의 구성요소 간 순서가 달라질 수 있다면?
    
    // 다시 말해서, 단순 nXm 직사각형 다중배열이 아니라 만들어진 배열 자체를 관리하는 복잡한 다중 배열을
    // 만들고, 수정하고, 호출하고 싶다면?

    // → 그 때 다중 포인턱 빛을 발합니다(꼭 필요합니다)

    // ----------------------------------------

    // 다중 포인터를 값으로 호출하고 싶을 때([] 없이)

    int x = 0; // 변수
    int* px = &x; // 포인터
    int** ppx = &px; // 포인터의 포인터, 혹은 &&x
    int*** pppx = &ppx; // 포인터의 포인터의 포인터, 혹은 &x의 &의 &, 혹은 &&&x

    // 호출 방법
    x; // = 0
    *px; // *(&x) = 0
    **ppx; // *(*(&&x)) = *(&*(&x)) = 0
    ***pppx; // ***&&&x = 0

    // 말로 풀어서 요약하면 : 다중 포인터를 값으로 호출하고 싶을 때는
    // 포인터 중첩만큼 호출하는 변수명 앞에 *을 붙이면 된다

    // (3중 포인터 변수면 ***, 극단적으로 10중 포인터 변수라면 **********)

    std::cout << x << std::endl;
    std::cout << *px << std::endl;
    std::cout << **ppx << std::endl;
    std::cout << ***pppx << std::endl;

    x = 1;

    // 호출 방법
    x; // = 1
    *px; // *(&x) = 1
    **ppx; // *(*(&&x)) = *(&*(&x)) = 1
    ***pppx; // ***&&&x = 1

    std::cout << x << std::endl;
    std::cout << *px << std::endl;
    std::cout << **ppx << std::endl;
    std::cout << ***pppx << std::endl;
} 