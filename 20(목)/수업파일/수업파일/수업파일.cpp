#include <iostream>
#include "Character.h"
#include "Potion.h"
#include "Granade.h"

// ----------------------------------------------------------------
// 
// 인터페이스를 썼을 때, 개발자가 주의해야 할 점, 혹은...

// "인터페이스의 세 가지 제약"
// 1. 가상 함수는 언제나 한 쌍으로 존재해야 한다(원본과 사본)
//    인터페이스가 만들어지는 순간, 파생 클래스는 존재해야 한다

// 2. 파생 클래스가 사용하는 가상 함수는 언제나 원본과 명칭이 일치해야 한다
//    인터페이스로서의 파생 클래스가 존재한다면, 가상함수는 반드시 원본의 것이 정의로 완결되어야 한다

// 3. 인터페이스로 만들어진 파생 클래스는 실제 취급은 원본처럼 다뤄진다
//    파생 클래스에서 만들어진 추가적인 데이터를 원본으로서 생성된 동안에는 밖에서 부를 수 없다

// ----------------------------------------------------------------

// 오늘의 코드에서 발견한 교훈 : C++은 상호참조를 기본적으로 지원하지 않습니다
//                             상호간에 참조가 필요한 경우, #include를 최대한 아끼고
//                             각 클래스에서 참조 대상 클래스 선언을 하도록 합시다

// → 앱의 성격에 따라서는 이런 특성 때문에 "상호참조 자체가 나쁘다"고도 합니다
//   그러나, 게임의 개발에서는 내적 상호작용이라는 특성상(캐릭터는 아이템을 쓰고, 아이템은 캐릭터에게 영향을 주고)
//   상호참조를 완전히 피해갈 수가 없습니다...! 그러므로 이렇게 상호참조가 필요할 때
//   어떻게 C++로 인한 오류를 막을 수 있을 지, 강사의 실수로부터 힌트를 얻어가도록 합시다!

// ----------------------------------------------------------------

int main()
{
    // 캐릭터(확인용)만들기
    Character* character = new Character();

    // 포션 만들고 캐릭터에게 주기
    Potion* tmp1 = new Potion(0, 1, 10);
    Potion* tmp2 = new Potion(1, 1, 100);
    Potion* tmp3 = new Potion(2, 2, 1000);

    character->i1 = tmp1;
    character->i2 = tmp2;
    character->i3 = tmp3;

    // 폭탄도 하나 만들어서 캐릭터의 3번 아이템으로 주기
    Item* gra1 = new Granade(4, 4, 500);
    character->i3 = gra1;

    // 아이템을 사용해보기
    // 캐릭터가 갖고 있는 -> 그 아이템이 갖고 있는 -> "사용" 기능 사용
    character->i1->Use(character);
    character->i2->Use(character);
    character->i3->Use(character); // 폭탄 사용이니까 아마 자해가 될 것

    character->i2->Use(character); // 폭탄 사용 후 사용하는 포션은 회복 효과가 있을 것

    // 아이템 1, 2번은 포션이니까 추가 함수 "복제"도 있는 상태
    // → 한번 사용?
    // character->i1->Duplicate(); // ← 오류!
    // 위의 i1은 아까 생성할 때 Item*로 생성했다
    // → 데이터는 자식 클래스지만, 실제 취급은 Item인 것
    // → 데이터 상으로는 사실 함수가 있지만... Item으로는 사실 복제 함수가 없는 거나 마찬가지
    // → 없는 함수니까 호출해도 사용할 수가 없는 것
    // → 다시 말해, 추가 변수 추가 함수를 만들 수는 있다. 스스로 쓸 수도 있다
    // → 그러나 Item으로 사용되는 동안, Item으로서(=밖에서는)해당 변수, 함수를 호출할 수는 없다
    
    // 반면, 자식 클래스를 그대로 만든 경우?
    Potion* tmpPotion = new Potion(9, 9, 9);
    tmpPotion->Duplicate(); // ← 자식으로 인스턴스를 만들면 복제 함수 부를 수 있다
}