#include <iostream>

// 문자열 함수를 사용하는 방법
// 문자열 함수를 C++에서 쓰려면 전용 기능을 불러와야 한다
// 이 기능 안에, c로부터 이어진 전통적인 함수부터 C++에서 맞춰진 편리하고 복잡한 함수까지 한 세트로 다 있다

#include <string.h> // 문자열을 쓰기 위한 기능 포함

int main()
{
    // string.h 안에 있는 함수들을 살펴보기 part1
    // c때부터 이어지는 문자열 관리 함수

    // 문자열 변수
    char word[101] = "반갑구나, 세상아!"; // 기준 문자열

    // 출력 (c 스타일)
    printf("%s", word);
    // ""로 출력하고, 그 중간에 %s라는 서식문자(데이터 대변 출력)를 포함하는데
    // 그 서식문자가 대변해야 할 대상은 word라는 변수다...라는 뜻
    printf("\n"); // ← 줄 바꿈(std::endl;)
    
    // 1. 문자열 더하기(원래 문자 뒤에 다른 문자를 또 적기)
    strcat_s(word, " 아니면 말고");
    // strcat_s : 첫 번째 변수로 받은 문자열에, 뒤에 오는 문자열을 더해서 그 결과를 저장하는 함수(conCATenate, 컨캐터닛, 이어붙이기)
    // 뒤에 있는  _s는 요즘 버전에서 함수를 안전하게 쓰려는 결과로 붙은 것

    printf("%s", word);
    printf("\n");

    // ---------------------------------------------
    // 2. 문자열 복제하기(다른 문자를 받아서, 그 데이터를 원래 문자 변수에 덮에씌우기)
    strcpy_s(word, "서울게임학원");

    printf("%s", word);
    printf("\n");

    // strcpy_s : 사람의 입장에서 생각하면, 사실 복제보다는 "수정"에 좀 더 가깝다
    //            원래 있던 문자열을 다른 문자열로 바꾸는 거니까

    // 그래서 문자열을 수정을 해야 할 때, 이 함수가 매우 유용하게 쓰인다
    // (물론 어디까지나 char[]이 쓰일 때 얘기지만...)

    // ---------------------------------------------

    // 3. 문자열의 길이 파악하기 (여기서 말하는 길이 : 바이트 수)
    int length = strlen(word); // 변수 수정이 아닌 단순 도출값 반환이라 안전하게 잘 쓰이는 함수

    printf("%s의 길이는 : %d입니다", word, length);
    // "무엇무엇의 길이는 얼마얼마라는 문자를 출력하며, 여기서 처음 지정된 서식문자(무엇무엇)에 word뒤에 나온 서식문자(얼마얼마)에 length를 대입(서식문자는 여러 번 출력 가능)

    printf("\n");

    // --------------------------------------------

    // 4. 문자열 변환하기(문자에 숫자인 경우, 그 숫자 자료형으로 바꿔준다)
    char data1[17] = "12345";
    char data2[17] = "123.45";
    char data3[17] = "12345678912345";

    // 각각 숫자를 받을 자료형
    int inform1 = atoi(data1);
    float inform2 = atof(data2);
    long long int inform3 = atoll(data3);
    // atoi, atof, atoll : 모두 'a'즉 문자를 각각 i, f, ll에 대응하는 숫자로 바꿔주는 함수
    // i : 정수, f : 소수, ll : 길고 긴 정수를 뜻한다

    // * atol()이란 함수도 있지만...지금은 더 이상 쓸모가 없어서 아무도 안 쓴다

    // * 추가로 주의할 점 : 적인 문자를 그대로 숫자로 만들진 못한다
    //                     소수를 계산할 때는 문자를 소수로 만드는 과정에서
    //                     다소 오차가 발생하는 경우도 드물지 않게 있다
    //                     atof()를 쓸 때 주의 필요
    
    // * 더 정확히 말하면... 기본적으로 컴퓨터는 소수 계산을 하면
    //   100% 정확한 계산을 하지 못하는 경우가 더 흔하다
    //   단지 현대에 들어서는 일반적으로 대부분의 연산이 끝났을 때
    //   과거의 개발자가 사람의 의도를 미리 해석해서 최대한의 비슷한 값 보정을
    //   해 주는 것뿐. 그리고 atof() 함수는 그런 보정을 안 해주는 케이스

    // 숫자를 출력
    printf("%d", inform1); // %d : 정수 출력
    printf("\n");
    printf("%f", inform2); // %f : 소수 출력
    printf("\n");
    printf("%d", inform3); // %d : 정수 출력
    printf("\n");

    // printf : 서식문자를 기준으로 각 변수를 출력
    //          변수와 서식문자가 규격이 다르면 변수의 일부 데이터가 유실

    // std::cout << inform3 << std::endl; ← cout은 규격에 자기가 알아서 다 맞춰준다

    // -------------------------------------------

    // 5. 문자열 자르기(혹은 나누기, 분리하기)
    //    : 기준이 되는 기호를 통해서 문자열을 둘로 나누는 것

    // 자르기용 문자열
    char list[100] = "CPU, GPU, RAM, 메인보드, 쿨러, SSD";
    
    // 자른 다음에 처리될 문자열
    char* cut = NULL; // ← 잘린 문자열 아무것도 지정 안 된 포인터란 뜻
    char* after = NULL; // ← 자른 다음에 남은 문자열을 저장하기 위한 포인터

    cut = strtok_s(list, ", ", &after);
    // list를 자르는데, 쉼표를 기준으로 자르고, 남은 결과를 after의 메모리 위치에 저장하는 함수
    // tok : "토큰"(token) 문자를 나누는 기준의 "형상"을 뜻한다

    printf("%s || %s", cut, after); // 잘린 문자과 잘린 다음에 남은 문자열 확인
    printf("\n");

    // 남은 문자열에서 또 자르기
    cut = strtok_s(after, ", ", &after);
    printf("%s || %s", cut, after);
    printf("\n");

    // 또 자르기
    cut = strtok_s(after, ", ", &after);
    printf("%s || %s", cut, after);
    printf("\n");

    // 이 과정을 반복하면 모든 문자열 자르기도 가능
    // → 원본 텍스트가 일정한 양식이라고 가정할 때, 
    //   기호에 따라 문자열을 나눠서 전부 배열로 저장하기 등도 가능
}