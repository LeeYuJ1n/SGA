// 재귀함수

#include <iostream>

using namespace std;

// 함수 작성
void RecursionExample()         // 함수 이름
{
    cout << "이렇게 코딩하면 망합니다" << endl;

    RecursionExample();      // 함수 안에서 그 함수의 이름 또 쓰기 (또 호출)
}

// 또 다른 예시를 위한 전역변수와 함수 선언
int number;

void IncreaseMe();

int main()
{
    // 작성딘 함수를 호출
    // RecursionExample();    ← 이 코드 부르면 망합니다

    // 작성된 함수 안에서, 자기 자신의 이름을 호출해서 다시 실행하는 것이 가능
    // (위 호출에서 확인)

    // 그리고 이렇게 자기 자신을 호출하도록 만들어진 함수를 "재귀 함수"라고 한다(recursion, 리커전 함수)

    // 일반적으로, 원칙적으로는 이런 재귀 함수는 선호되는 방식은 아니다
    
    // 하지만 선호되지 않음에도 불구하고 이 코딩 기법이 금지되지 않고 이어지는 이유
    // : 적재적소에 활용하면 코딩 길이를 획기적으로 줄일 수 있기 때문

    number = 0;       // 전역변수에 값 할당 후
    // "증가"라는 이름의 함수를 실행

    IncreaseMe();

    // 결과를 출력
    cout << number << endl;

    // 재귀 함수를 그래서 왜 쓰느냐?
    // 1. 코딩의 길이를 줄일 수 있기 때문에
    // 2. 적절하게 사용한 재귀함수는 while과 비슷한 역할을 한다 (똑같지는 않지만)
    //    특정 조건 하에서 무한히 동작한다는 그 사실 자체가 필요할 수 있어서
    //    (특히 해당 연산을 main이나 반복문이 아닌 다른 클래스 등에서 동작해야 할 경우)

    // 재귀 함수가 쓰인 프로그래밍 사례 혹은 예제 중 대표적인 것으로
    // <하노이의 탑> 이라는 문제가 있다 (관심 있는 분들은 한 번 찾아봅시다)
}

void IncreaseMe()          // "증가"라는 이름의 함수를 정의
{
    // 전역변수 number를 100까지 올릴 것이다
    // 단, 재귀로
    number++;      // 숫자 +1

    if (number > 100) return;
    // 이것이 재귀함수를 무한히 재귀하지 못하도록 만드는 방법 1
    // 재귀가 끝나야 하는 시점이 오면, 즉시 함수 자체를 종료 (재귀하지 않고)
    // * void 함수는 return에 값을 주지 않고 수행 가능 (void 함수 강종 방법)

    // 위에 return 코드가 쓰인 경우라면 그냥 함수를 바로 불러도 괜찮다
    // IncreaseMe(); ← 이렇게

    if (number < 100) IncreaseMe();
    // 이것이 재귀함수를 무한히 재귀하지 못하도록 만드는 방법 2
    // 재귀자체에 조건을 걸어도 무한동력 차단 가능
}