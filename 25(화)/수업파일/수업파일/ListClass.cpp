#include "ListClass.h"

using namespace std;

void ListClass::Start()
{
	// 리스트 써보기

	list<int> intList; // 리스트 작성(선언)방법

	// 값을 채우기
	for (int i = 0; i < 10; ++i)
	{
		intList.push_back(i + 1); // 1부터 10까지
	}

	// 값을 출력하기
	// list는 반복자를 써서 값에 접근해야 합니다
	
	// 반복자 선언 및 초기화. 벡터와 똑같다
	list<int>::iterator iter = intList.begin();

	// 순번을 돌리기 위한 반복문(각 차례의 값을 출력하기 위함)
	for (int i = 0; i < 10; ++i)
	{
		// cout << intList[i] << endl;
		// list는 []로 순번에 접근할 수가 없습니다

		iter = intList.begin(); // 작은 반복문 시작 전 마다 반복자 리셋

		// 반복자를 조작하기 위한 반복문(해당 차례가 올 때까지 반복자를 증가시키기 위함)
		for (int j = 0; j < i; ++j)
		{
			iter++;
		}
		cout << *iter << endl; // iter의 값 호출

		// iter = intList.begin();
		// cout << *(iter + i) << endl; ← 아쉽게도 반복자에 +n 계산 불가능
	}
	// []도 쓸 수 없는 불편한 list가 왜 쓰이는가?
	// → 메모리 효율과 삽입, 삭제의 빠른 속도 때문에
	//   (메모리가 불연속적이므로 사본에 집착할 필요가 없다)

	// insert, emplace, erase 사용 및 반복자 시험

	iter = intList.begin(); // 반복자를 처음으로 리셋

	iter++;
	iter++; // 순번 +2

	intList.insert(iter, 111);

	// 반복자 리셋 없이 진행 : list는 이대로 코드 수행
	// → list는 삽입, 추가 시에 사본이 만들어지지 않는다는 것도 확인
	// → 삽입, 추가가 끝난 다음에 추가된 "새 요소"의 위치로 iter가 맞춰진다
	//	 : insert, emplace는 반복자가 반환형인 함수(호출만 해도 iter가 바뀌는)

	iter++;
	iter++; // 순번 +2

	intList.emplace(iter, 222);

	iter++;
	iter++;
	
	intList.erase(iter);
	// → 어??
	// → 삽입, 추가가 삽입, 추가된 요소로 반복자를 맞춰준다면...
	// → 삭제도 삭제된 요소를 반복자가 맞춰지지 않을까???
	// → 그러면... 여기는 참조가 될 "다음 데이터"가 없어질 텐데(리스트에서 빠지니까)
	// → 정말로 그렇게 된다.

	// 삭제를 사용하면 list의 특성으로 인해 반복자를 계산에 더 이상 쓸 수 없다
	// 삭제 후엔 벡터처럼 반복자를 다시 시작으로 리셋해주어야 한다

	// 그래서 실험 : 순번을 다시 2 뒤로 물리고 333추가
	// // ...는 불가능
	// iter++;
	// iter++;
	// intList.emplace(iter, 333);

	// 다시 출력
	for (int i = 0; i < intList.size(); ++i) // intList의 현재 크기에 맞추도록
	{
		iter = intList.begin();

		for (int j = 0; j < i; ++j)
		{
			iter++;
		}
		cout << *iter << endl;
	}
	// 나머지는 기본적으로 벡터와 리스트가 사용방법을 공유하기 때문에
	// pop_back, clear, size, resize 다 된다(at 빼고)

	// 기본적으로 쓰는 방법만 알려는게 목적이라면 벡터만 파도 충분하다
	// 단지 내부의 메커니즘을 알아두면 경우에 따라 좀 더 효율적인
	// 동적 배열을 선택할 수도 있을 뿐

	// 그러면 벡타와 리스트 중에서 언제, 어느 쪽이 더 효율적인가?

	// 리스트 : 자료의 삽입, 추가, 삭제가 매우 빠르다
	//          사본 형성을 잘 안해서 메모리 효율도 높다
	//		    → 따라서 수정이 자주 일어나는 데이터 관리에 써먹으면 좋다
	//          (이를테면 대화 로그, MMORPG 등에서 플레이어 스킬북(스킬 포인트 창 아님))
	//			반면, 참조가 느리다, 연산 코드 짜기도 번거롭다
	//			→ 자주 열고 봐야 되는 데이터를 리스트로 만들면 나중에 귀찮을지도
	//			(이를테면 인벤토리, 스킬 포인트 분배, 파티 구성창 등)

	// 벡터 : 메모리 효율이 다소 좋지 못하다
	//		  삽입, 추가, 삭제 시에 클래스 내부에서 연산이 복잡하다(= 느리다)
	//		  → 자주 수정이 일어나는 데이터 관리에는 최적의 선택은 아니다
	//		  반면 한 번 만들어진 배열을 다시 참조하는 건 매우 빠르다
	//        → 자주 배열을 참조해야 할 때 벡터를 쓰면 좋다
	//		  → 특히 크기가 변해야 하면(인스턴스 파티 등)벡터는 필수

	// 각자 실습해봅시다 : 벡터의 함수를 리스트에서 써보기(at 빼고)
	//                    + 반복자를 이용해서 리스트 다뤄보기

	for (list<int>::iterator it = intList.begin();
		it != intList.end();
		++it)
	{
		// 대충 이런 식으로
	}
}