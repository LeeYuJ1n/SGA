#include <iostream>

using namespace std;

// 하노이의 탑 재귀함수로 도전

// 1. 하노이의 탑의 목표 : 크기(내림차순으)로 쌓아올린 탑이 있는데
//                        그 탑을 다른 쪽으로 옮겨야 한다

// 2. 하노이의 탑의 제약 : 크기가 큰 블럭(=순서로 따져서 순번이 낮은 블럭)은
//                        크기가 작은 블럭 (=순번이 높은 블럭) 위로 못 간다
//                        (1번 블럭은 2번 블럭 위로 갈 수 없다)

// 3. 하노이의 탑의 자유 : 옮겨야 하는 진짜 목적지 외에, 블럭을 쌓을 수 있는
//                        다른 빈 공간을 하나 더 준다

// -----------------------------------------------------

// 위 규칙에 따라서, 하노이의 탑을 풀려고 했을 때 가장 문제가 되는 것?
// → 가장 밑에 있는 블럭을 어떻게 움직이야 하는가?
// → 답 : "그거 빼고 나머지 전부"를 다른 곳으로 옮겨야 한다
// → N단 탑을 옮기려면, 먼저 N-1단까지의 모든 블럭은 딴 곳으로 가야 한다

void Hanoi(int stack, int from, int to, int check)
// stack : 단 수, from : 출발지, to : 목적지
// check : 체크포인트. 계산 자체로는 쓰이지 않는다 (목적지도, 출발지도 아니니까)
//         하지만 "다른 곳으로 간다"는 상황을 전달하기 위해서 필요하다
{
    // 탑이 1단인 경우??? 퍼즐을 풀 필요가 없다
    // + 어떤 탑을 옮기든 맨 마지막은 제일 위의 한 단을 옮겨야 한다
    // 그러므로 해당 경우를 먼저 (조건문으로) 빼놓고 나머지를 생각해보자

    if (stack != 1)
    {
        // N-1단까지 모든 블럭은 딴 곳으로 가야 한다
        Hanoi(stack - 1, from, check, to);
        // 체크포인트(다른 빈 곳)를 새로운 목적지로 지정해서 N-1단을 다 보낸다
        // 남아도는 목적지 to를 다음 계산을 대비해서 매개변수로 다시 넘긴다

        // 그리고 최후의 계산이 끝나면 제일 위부터 블럭이 움직이는 기록이 나온다 (끝단부터)
        // 그리고 각 계산이 끝난 후, (위 재귀함수 루프가 끝난 후) 제일 첫 단이 움직이는 기록이 나온다

        // 그러면 그 첫 단의 움직임을 출력 (목적지로 가기)
        cout << from << "에서 " << to << "로 이동!" << endl;

        // N-1단 (지금은 딴 곳에 있는) 탑을 다시 딴 곳에서 진짜 목적지로 이동
        Hanoi(stack - 1, check, to, from);
        // 체크포인트를 시작지로, 목적지를 최종 목표로, 남아도는 from은 맨 뒤로
    }
    else
    {
        // 단이 1단까지 내려왔거나 (제일 큰 거)
        // 애초에 탑이 1층이거나 (=이게 지금 꼭대기거나)

        cout << from << "에서 " << to << "로 이동!" << endl;
    }
}

int main()
{
    int towerHeight;

    cin >> towerHeight;        // 탑의 높이를 입력을 받기

    // 하노이의 탑 실행
    Hanoi(towerHeight, 1, 2, 3);
    // 1에서 2로, 3은 빈 곳
}