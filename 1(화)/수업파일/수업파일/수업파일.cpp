#include <iostream>

using namespace std;

// 함수 포인터
// 함수 포인터 : 함수의 메모리 위치를 나타내는 (다른 함수 속, 혹은 전역) 변수
// → 함수 포인터가 있으려면? 당연히 함수가 필요하다

// 1. 함수 포인터를 만들기 위함 함수
void Print()
{
    cout << "헬로, 월드!" << endl;
}

// 함수 몇 개만 더
void PrintThese(int x, int y)
{
    cout << x << " 그리고" << y << endl;
}

void PrintFromAdd(int x, int y)
{
    cout << x << "에 " << y << "를 더해서" << x + y << endl;
}

void PrintFromOp(int x, int y)
{
    // 이름은 일단 만들었는데 뭘 할지 모르겠는 그냥 함수
}

// -----------------------------------------------------

// 실습
void TestSub(int x, int y)
{
    cout << x << " - " << y << " = " << x - y << endl;
}

// -----------------------------------------------------

// 함수 작성 후 main에서 써봅시다

int main()
{
    // 2. 함수를 써보기
    Print();               // 헬로 월드
    PrintThese(1, 2);      // 숫자 출력
    PrintFromAdd(3, 10);   // 합계 계산
    PrintFromOp(100, 200); // ← 내용이 없어서 아마 의미는 없겠지만

    // 3. 함수의 이름을 출력해보기 (배열처럼)
    // cout << print() << endl;
    // → 함수 이름 뒤에 ()를 붙이면 함수를 실행한 다음 결과를 출력
    // → 이런 사용은 지금 의도하는 바가 아닙니다

    cout << Print << endl;           // ← () 없이 함수 이름만 출력
    cout << PrintThese << endl;
    cout << PrintFromAdd << endl;
    cout << PrintFromOp << endl;
    // → 안에 내용은 없어도, 함수가 선언 혹은 정의되었다는 것만으로도 메모리 주소는 생깁니다

    // → 함수의 이름으로 함수의 메모리 주소를 호출할 수 있다
    // → 함수에도 포인터는 존재할 수 있다

    // 4. 함수를 위한 포인터는 어떻게 작성해야 될까?
    
    // * 자바스크립트나, 일부 라이브러리를 적용한 자바, NFT언어(솔리디티)...언어들이라면
    // "function"이라는 명령어 하나만 가지고 포인터를 만들 수는 있지만, C++에서는 그런 거 없다
    
    // C++에서는 템플릿을 호출하거나, 클래스 하나를 지정해서 사용했을 때와 비슷한 느낌으로
    // (문법은 조금 다름) 포인터로 받기 위한 함수가 어떤 형식인지 매번 선언할 떄 지정을 해줘야

    void (*functionPointer)();
    // 여기서 쓰인 도식 명령어 (사례 기준)
    // void : 이 포인터가 지망하는 대상 함수의 반환형 (=void 함수를 받겠다)
    // (* ) : 해당 함수의 메모리 주소를 받겠다, 포인터 선언.
    //        괄호를 쓰는 이유 : "함수"라는 대상의 메모리 주소만 받기 위해서 (우선순위 지정)
    // (* )에 들어간 이름 : 포인터의 이름, 변수의 이름. int a = 0의 a와 같다
    // 맨 마지막에 쓰인 () : 해당 함수에서 받아야 할 매개변수
    //                      여기서는 매개변수가 없는 함수를 받겠다는 뜻

    void (*f_ptr2)(int, int);
    // 마지막 괄호에 int, int : 이 포인터의 대상 함수에는 정수 두 개를 매개변수 둘이 필요하다
    // * 여기서 (int, int)에 매개변수의 이름을 쓰지 않았음에 주목
    //   (어떤 매개변수가 어디서 쓰인다는 정의가 아닌 형식의 선언이 중요하니까)

    // 위 처럼 포인터를 선언하면 해당 이름으로 포인터를 사용할 수 있다

    // 5. 함수 포인터의 사용

    // → 할당은 (포인터) 변수처럼
    // → 호출은 함수처럼

    functionPointer = Print;                      // ← 함수 이름을 포인터에 그대로 할당
                                                  //   함수 이름 : 메모리 주소니까!

    functionPointer();                            // ← 포인터로 할당된 메모리 위치에 있던 함수 사용
    
    f_ptr2 = PrintThese;                          // 정수 두 개 출력하던 함수를 할당

    f_ptr2(111, 222);                             // 포인터 실행

    f_ptr2 = PrintFromAdd;                        // 변수니까 수정도 가능 : 덧셈으로 다시 할당

    f_ptr2(111, 222);                             // 똑같은 이름, 똑같은 매개변수로 포인터 할당

    // 함수 포인터를 사용한 이유
    // : 이벤트(어떤 조건이 달성될 때 자동 혹은 수동 실행해야 할 결과)를 만들기 위해서
    // : 콜백을 만들기 위해서

    // 1. 호출할 수 있는 명령어가 인터페이스에서 한정되어 있을 때,
    //    해당 호출이 수행할 진짜 연산이 무엇인지를 상황에 따라 조절하기 위해서
    //    → 이벤트의 통제

    // 2. 포인터와, 함수와, 호출 시점이 정해져 있을 때,
    //    그런데 정작 함수의 내용은 정해진 게 없을 때,
    //    다른 사람(혹은 미래의 나)이 *분담해서* 해당 시점에서 수행해야 할 코드를 작성 가능
    //    → 이벤트의 정의

    //    2.의 사례 : 게임 개발에서 "캐릭터 피격 시에 수행할 동작" 같은 걸 작성

    // 3. 함수의 내용도 있고, 실행 방법도 있지만, 정작 언제, 어디서 심지어
    //    * 누가 * 호출해야 할지도 확실하지 않을 때, 함수의 내용을 잠깐 대기시키려고
    //    → 나중에 꼭 필요할 때, 꼭 필요한 주체가(클래스든, 유저든) 함수를 실행

    //    → 이런 프로그래밍을 "콜백"이라고 한다

    // -----------------------------------------

    // 실습
    void (*testPrint)(int, int);

    testPrint = TestSub;

    testPrint(200, 100);

    testPrint(300, 100);

    // -----------------------------------------
}