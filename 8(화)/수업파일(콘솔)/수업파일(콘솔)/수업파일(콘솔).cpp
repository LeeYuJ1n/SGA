#include <iostream>

using namespace std;

// 정적 선언 변수 (정적 변수, static variables)

int a = 0;                // ← 우리가 아는 변수의 초기화 형태
static int b = 1;         // ← 변수 자료형 앞에 static을 붙이면 정적 변수

// 정적 변수는 정적이 아닌 변수와 무엇이 다른가?
// → 우리가 지금껏 사용했던 변수는 모두 동적 변수
//   여기서 동적이라는 말의 뜻 : 메모리 위치, 생성과 소멸이 모두 "자유롭게" 이루어진다
//   어떻게 자유롭길래? → 개발자 입장에서는 어차피 코딩으로 쓰는 건데 다 자유롭지 않은가?
//   → 따라서, 변수가 자유롭다고 할 때, 자유의 주체 = 컴퓨터
//   → 개발자만이 아니라, 컴퓨터도 앱 실행 중에 변수의 위치, 생성, 소멸 등을 마음대로 한다는 뜻

// 지금껏 써 온 일반 변수 (=동적변수)의 특성을 확인해보기 위한 함수
int GiveMeDynamic()
{
    // 이전에... 지역변수에 대해 이야기할 때 언급했던 특성
    // "{} 안에서 만든 변수는 {} 안에서만 유효하고, }가 끝나면 없어진다"

    // 여기서 number가 만들어진다
    int number = 0; // number라는 변수를 여기에 선언 (+초기화)
    // 함수가 반복 수행될 때마다 위 코드가 작동이 되는 이유도 number가 (실행 시점에) 없었기 때문에

    number++;       // 숫자에 +1

    return number;  // number를 컴퓨터에게 준다. 예상 값은 1
    // 위 return이 끝나면, 함수가 끝나면서 number가 없어진다
}

// 반면, 정적 변수(static)는 한 번 만들어지면 그 위치, 생성, 소멸 등의 관리가 자유롭지 않다
// → 컴퓨터의 입장에서 이 변수를 마음대로 만들거나, 옮기거나, 지우지 못한다 (개발자가 지정한 코드가 없는 한)
//   그리고 코드상 같은 변수 생성 명령을 다시 받을 경우 → 정적 변수는 해당 명령을 컴퓨터가 무시한다

// 정적 변수의 특성을 알 수 있는 함수
int GiveMeStatic()
{
    // 정적 변수를 선언 후 초기화
    static int number = 0;   // 정적 변수가 생성
    // 이 함수가 두 번 실행될 경우, number가 이미 하나 존재하는 셈이 된다
    // 한 번 정의된 변수가 다시 선언되면 에러가 나야 하므로 
    // → 함수에서 선언된 정적 (지역)변수는 두 번째 선언부터는 명령을 컴퓨터가 무시

    number++;    // 위쪽 함수와 똑같이 +1
    // 이 함수를 처음 실행할 경우라면 처음 만들어진 0에서 +1 → 1
    // 이 함수를 두 번 실행할 경우, 처음 만들어진 후, 한 번 +1이 된 값에 다시 +1 → 2
    // n번 실행하면? +1을 n번 반복하는 셈 → n이 된다

    return number; // 숫자 반환
    // 위 코드가 실행되고 함수가 끝나면 → number가 없어지지 않는다 (메모리 그 위치에 그대로 있다)
}

// 정리 : 정적 변수는 메모리 내에 존재의 관리를 개발자가 100% 수동으로 하려고 만든 것
//        수동으로 지우지 않는 한, 계속 그 자리에 남아있다 (강제 전역 변수화)

// 진짜 전역 변수와의 차이 : 메모리에 데이터는 있지만, 정적 변수가 지역 변수일 경우
//                         다른 함수 등에서 직접 호출을 하지는 못한다

// 정적 변수를 그래서 왜 쓰는가? :
// 1. 한 프로그램에서 해당 데이터를 갖고 있는 변수가 딱 하나만 있어야 할 때
//    (프로그램의 ID, 클래스나 구조체의 형태일 경우, 해당 기능이나 데이터  집합이 무조건 하나일 때)
//    ("현재 접속 중인 온라인 게임 캐릭터", "현재 플레이어의 닉네임", "오피스 프로그램의 파일 저장 시스템", "텍스처 캐시")
// 2. 전역 변수가 필요하지만, 그렇다고 해당 변수를 아무데서나 고쳐서는 곤란할 때
//    (위에서 언급한 게임 캐릭터 정보, 텍스처 캐시 등의 정보를 다른 코드나 클래스에서 막 바꾸면 좋지 않다)
// 3. 전역 변수로 사용하는 게 너무 당연해서 별도의 공간에서 선언을 하는 것조차 복잡해질 때

// 1, 2, 3 의 경우에 두 가지 이상 해당이 되는 데이터라면 → 정적 변수를 고려하는 것도 좋다

// 반대로 static이 있으나 없으나 거기서 거기라면 붙일 필요는 없을 수도 있다
// 전역변수... 혹은 main 밖에서 만드는 함수 (전역 함수) 등은 어차피 외부에서 다 접근 되고,
// 가장 밖에서 (=존재하려면 유일할 수 밖에 없는 곳)에서 만들어지니까 굳이 static이 필요하진 않다

// → 정적 변수의 개념은 이후 클래스와 참조 등이 일상적으로 벌어지는 환경
//   다시 말해 복잡한 윈도우용 C++ 혹은 WinAPI 환경 등에서 유용하게 쓰인다

// * 정적 선언은 변수 외에 함수에도 적용 가능하다 (static void 함수 같은 것)
// * 정적 변수는 단일 자료형 변수 외에 구조체, 클래스 등에도 적용 가능하다
// → 선언 가능한 대상 데이터는 대체로 정적 선언이 된다

// * 정적 선언을 사용할 때 주의점
//   : 수동으로 만든다 + 자동으로 안 지워진다
//   = 지우는 것도 수동으로 안 하면 메모리에 낭비가 생긴다
//   → 지울 수 없는 데이터를 정적 선언으로 만들 경우, 메모리에 "필요악"에 의한 점거 발생
//     (=지우지도 못할 거면서 컴퓨터 성능만 잡아먹는다는 이야기. 다른 말로 "메모리 누출" memory leak이라고 한다)

//   이런 메모리 누출의 대표적인 사례 : 반환용 변수를 정적으로 만드는 것
//                                    지우면 → 반환불가, 반환하면 → (함수가 끝나서) 삭제 불가능
//                                    정적으로 안 만들면 → 함수가 의도대로 동작 안함

// 그럼에도 불구하고 "꼭 필요해서" 메모리 누출을 감수하고 데이터를 만들어야 할 때도 있다
// → 그래서 주의가 더욱 필요

// 정적 선언 코드를 어떻게 더 응용할 수 있는가? → 다른 프로젝트에서 확인

int main()
{
    // 만든 전역변수 시험 출력
    cout << a << endl;
    cout << b << endl;

    cout << endl;

    cout << GiveMeDynamic() << endl;          // ← 동적 변수 출력, 예상 값은 1
    cout << GiveMeDynamic() << endl;          // 똑같은 함수 한 번 더 출력? 갑은 1

    cout << endl;

    cout << GiveMeStatic() << endl;           // ← 정적 변수 출력, 예상 값은 1
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;
    cout << GiveMeStatic() << endl;

    // cout << number << endl; ← 지역 변수를 다른곳에서 호출은 못한다 (정적 변수 = 지금 존재하는
}