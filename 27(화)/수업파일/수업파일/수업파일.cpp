#include <iostream>

int main()
{
    // 연산자(복습 및 보강)

    // 연산자 (Operator, OpCode) : 수학에서 말하는 "계산부호", "연산 부호"
    // → 수학적 계산 혹은 두 자료 사이의 관계를 정의하는 기호(용어의 정의)
    // → 자료형 혹은 데이터 자체를 변경하기 위한 명령어를 기호로 줄인 것(실제 이해)

    // 다시 말해 연산자의 본질은 결국 "이렇게 해주세요, 저렇게 해주세요"의 줄임말

    // -----------------------------------------

    // 연산자의 종류

    // 1. 사칙연산 : +, -, *, /
    // → 기본적인 산수 계산을 위한 기호 혹은 연산자

    // 2. 사칙연산의 부속기호 : %
    // → 사칙연산 중, int간 나누기에 의해 생기는 나머지를 도출하기 위한 연산자

    // 3. 할당 연산자(정의 연산자) : =
    // → 변수에 값을 할당하기 위한 연산자
    // 뜻은 A = b →  A는 B다
    // A와 B는 "같다"는 비교의 의미가 아니다. 그냥 A를 지금부터 B라는 의미로 쓰겠다는 의미
    int a = 1; // A와 1이라는 숫자를 비교하겠다는 뜻이 아니라, 1이라는 숫자를 a라는 이름으로 혹은 a를 지금부터 1이라는 뜻으로 쓰겠다고 컴퓨터한테 개발자가 일방적으로 통보하는 것

    // * 변수를 수정할 수 있고 할당 연산자를 쓸 때, 변수 자기 자신을 연산식에 넣을 수도 있다
    a = a; // 가능 → "나는 나다"가 아니라 "a라는 이름으로 방금 정해진 값을 앞으로도 쓰겠다

    a = a + 1; // 가능 → "방금까지 정해졌던 a라는 숫자에 지금부터 1을 더하겠다"

    a = a - 1; // 가능
    a = a * 1; // 가능
    a = a - 1; // 가능
    a = a % 1; // 가능

    // .....다만 보통은 이 경우 +, -, *정도가 자주 선택된다(사람들이 그렇게 쓴다는 이야기)

    // 4. 누적 연산자 : 자기 자신을 사용하는 산수 연산식의 표현을 줄여서 연산자로 만든 것
    a += 1; // a = a + 1하고 같은 뜻 → 즉 "방금까지 정해졌던 a라는 숫자에 지금부터 1을 더하겠다

    a -= 1; // a = a - 1
    a *= 1; // a = a * 1
    a /= 1; // a = a / 1
    // a %= 1; → 에러가 날 것 같진 않지만 웬만해선 잘 안 쓴다

    // 5. 증간 연산자 : 누적 연산자의 연장이며, +, -가 자기 자신에게 적용되는 경우 중 증강폭이 1일 때 씀
    a++; // a = a + 1, a += 1 이 두 식과 완전히 같은 뜻
    a--; // a = a - 1, a -= 1이 두 식과 완전히 같은 뜻

    ++a; // a = a + 1, a += 1 이 두 식과 완전히 같은 뜻
    --a; // a = a - 1, a -= 1이 두 식과 완전히 같은 뜻

    // ++, --는 변수명 왼쪽에도 붙을 수 있고, 오른쪽에도 붙을 수 있다
    // 그런데 붙는 위치에 따라 미묘하게 의미가 다르다

    // ++가 왼쪽에 붙을 경우, 전위 연산자(전위 증간 연산자)라고 한다
    ++a; // 전위
    --a; // 전위

    // 전위 연산자의 특징 : 변수를 호출할 때연산부터 끝내놓고 호출한다
    // = 일단 1을 더해놓고(해놓고) 호출(사용)한다
    // 그래서 출력 등을 할 때 ++a를 사용하면 부르기 전보다 항상 1이 올라가 있다
    
    // 따라서 미묘하게 처리가 빠른 경우가 많다(늘 그렇진 않지만 대체로)
    // 그리고 호출이(출력 등을 할 때) 사용자가 결과를 이미 보고 있다

    int test_1 = 10;
    std::cout << test_1 << std::endl;
    std::cout << ++test_1 << std::endl;
    std::cout << --test_1 << std::endl;

    // ++가 오른쪽에 붙을 경우, 후위 연산자(후위 증간 연산자) 라고 한다

    a++; // 후위
    a--; // 후위

    // 후위 연산자의 특징 : 변수를 호출할 때는 연산을 아직 안 합니다
    // → 일단 호출을 하고(사용이나 출력을 하고) 호출이 끝난 후에 연산을 한다(결과를 반영)

    // 후위 연산자는 출력따로 연산따로 : (늘 그렇다는 건 아니지만)대체로 미묘하게 느려진다
    // 연산을 하려고 할 때, 일단 원본 값을 당장은 보존하면서 연산할(출력할) 수 있다
    // 일단 원본을 보여주고 그 다음에 수정을 해야 한다면, 그 때는 후위 연산자가 더 적절할 수도 있다

    int test_2 = 20;
    std::cout << test_2 << std::endl;
    std::cout << test_2++ << std::endl; // 여기서 출력은 test_2가 나오고, 그 뒤에 ++가 연산
    std::cout << test_2-- << std::endl; // 출력은 위에서 ++한 21이 먼저 나오고 그 뒤에...
    std::cout << test_2 << std::endl; // 여기서 윗줄 --가 적용된 결과를 확인 가능!

    // "전위 연산자와 후위 연산자가 간혹 동시에 작성될 가능성이 있는데 (++++a, a++++, ++a++)
    // 이 경우.....언어마다 이 코드를 처리하는 방법이 중구난방입니다
    // 어떤 언어는 바로 에러, 어떤 언어는 전위 연산자가 먼저 실행, 어떤 언어는 후위 연산자가 먼저 실행
    // → 그렇기 때문에 공연히 복잡하게 외우느니 **그냥 전위 연산자와 후위 연산자는 동시에 쓰지 맙시다**
    
    // -----------------------------------------

    // <숫자와 데이터에 대한 것들>을 산술 연산자라고도 한다(중요하지는 않음)

    // 산술 연산자에는 추가 특징 : 자기들끼리 연산의 우선순위가 있다
    // (모든 연산자에 우선순위가 있지만, 다른 연산자의 경우 종류가 달라서 혼란이 많진 않다)
    
    // 사칙연산에 적용되는 우선순위 : *, /가 +, -보다 우선
    // 할당 연산자는 산술 연산이 다 끝나고 나야 연산이 적용
    // 증강 연산자의 경우 모든 사칙연산보자 우선순위가 높다
    // *증강 연산자끼리는 언어마다 우선순위가 다르다(언어에 따라 중복 사용 자체를 금지할 수도 있다)

    // 그래서 연산자를 사용할 때는 우선순위에 어느 정도 주의를 기울이면 좋다

    // 혹은..... 개발자가 원하는 우선순위가 있다면(혹은 원래 그냥 적용되는 우선순위라도)
    // 연산식에서 확실하게 지정하거나 표현할 수도 있다(아래의 연산자)

    // ------------------------------------------

    // () : 범위 지정 연산자(스코프)

    // () 안과 밖에 각각 연산식이 있을 경우, ()안에 있는 식을 우선한다(연산자 간 우선순위 부분 무시)
    // () 안에 있음으로서 우선되는 식은 산숙 연산자만이 아니라 다른 모든 연산식, 코드 등에도 적용된다
    // 대표적인 경우가 바로 if(이거) while(이거) : "이거"부터 먼저 계산하고, 그게 맞는지를 조건문에서 판단

    std::cout << 1 + 2 * 3 << std::endl; // 2 * 3을 먼저하고(6) → 1 + 6 해서 7
    std::cout << (1 + 2) * 3 << std::endl; // 1 + 2을 먼저 해서(3) → 3 * 3 해서 9

    // --------------------------------------------
    
    // 두 데이터 간의 관계에 대해, 혹은 한 데이터의 성질에 대한 연산자들
    // : 논리 연산자

    // 1. 논리합 : 기호는 || 
    // 기호 왼쪽, 혹은 오른쪽 중 어느 하나만 참이어도 맞는 걸로 치겠다는 뜻
    // 집합으로 치면 합집합(합 집합이라서 논리합)

    bool logic_1 = true || false; // 왼쪽이 참인 경우
    bool logic_2 = false || true; // 오른쪽이 참
    bool logic_3 = true || true; // 둘 다 참
    bool logic_4 = false || false; // 둘 다 거짓

    // 왼쪽 오른쪽 각각 참과 거짓을 주고, 왼쪽이 참이면 최종결과도 참이 되는 변수 4개

    std::cout << logic_1 << std::endl;
    std::cout << logic_2 << std::endl;
    std::cout << logic_3 << std::endl;
    std::cout << logic_4 << std::endl;

    // 2. 논리곱 : 기호는 &&
    // 기호 왼쪽과 오른쪽이 모두 참이어야만 맞는 걸로 치겠다는 뜻
    // 하나만 참이 아니어도 틀린 걸로 치겠다는 뜻
    // 집합으로 치면 교집합(교/곱 집합이라서 논리곱)

    bool inter_1 = true && false;
    bool inter_2 = false && true;
    bool inter_3 = true && true;
    bool inter_4 = false && false;

    std::cout << inter_1 << std::endl;
    std::cout << inter_2 << std::endl;
    std::cout << inter_3 << std::endl;
    std::cout << inter_4 << std::endl;

    // 3. 부정 : 기호는 !
    // 뜻은 ! 기호 오른쪽에 있는 모든 식"이 아니다"라는 뜻

    bool negative = false; // 부정이라는 이름의, 부정이라는 값의 bool 변수

    std::cout << negative << std::endl; // false가 출력
    std::cout << !negative << std::endl; // ! + negative = "negative"가 아니라는 뜻

    // 여기서 "아니다"의 범위가 어디까지 갈까?

    int cur = 0; // 숫자 0, bool로 치면 false
    std::cout << !cur << std::endl; // cur이 아니라는 건 무슨 의미일까?

    // 현실의 밥식으로 생각하자면, 숫자가 0이 아니란 건 "0 빼고 전부 다"라는 뜻도 있겠지만
    // 컴퓨터의 방식으로는 숫자가 0이 아니라는 건 그냥 "데이터가 있다"는 뜻일 뿐
    // → int의 방식으로든, bool의 방식으로든 결과는 그냥 1

    // → bool 변수를 다루려고 할 때 ! 기호를 적절히 잘 사용하면 대단히 유용
    // 나머지 경우 (구체적인 데이터가 필요한 숫자나 상황이라면) → 그냥 계산을 직접 하는 편이 좋다

    // ---------------------------------------

    // 논리 연산자도 산술 연산자처럼 한 식에서 여러 번 쓸 수 있다
    // 추가로, 논리 연산자 끼리도 ()가 적용된다( : ()는 사실 모든 연산자에 적용)

    // bool 변수 추가로 확인

    bool ext_1 = true || false && false || true;
    bool ext_2 = (true || false) && (false || true);
    bool ext_3 = (true && false) || (false && true);
    bool ext_4 = (true && false) && (false && true);
    bool ext_5 = true && false && false || true;

    std::cout << ext_1 << std::endl;
    std::cout << ext_2 << std::endl;
    std::cout << ext_3 << std::endl;
    std::cout << ext_4 << std::endl;
    std::cout << ext_5 << std::endl;

    // ---------------------------------------

    // 논리 연산자를 현실에서 개발에 쓸 때, 제일 중요한 (몰라도 외워야 할 공식은 사실 단 두 개)

    // a && b && c && d && e → abcde가 싹 다 참이어야 맞는 것
    // a || b || c || d || e → abcde 중에 하나만 참이어도 맞는 것

    // 물론 ()가 있으면 괄호 먼저

    // -------------------------------------

    // 비교 연산자 : 논리 연산자와 비슷한 역할이지만 범주가 조금 다르다
    
    // 조건이 충족되기 위한 경우의 수가 하나뿐인 논리 연산자와는 달리, 비교 연산자는 서로의 조건을 충족할 수 있는 경웅인 수가 한정되저 있지 않다

    // 비교용 숫자 두 개
    int comp_1 = 200; // 기본값은 100
    int comp_2 = 200; // 기본값은 200

    // 실제 비교 연산식과, 그 결과를 저장할 bool 변수
    bool compare;

    // 실제 비교 연산식(과 그 결과를 bool 변수에 저장하기)
    compare = comp_1 > comp_2; // > : 왼쪽이 오른쪽보다 크다
    std::cout << compare << std::endl;

    // 비교 대상 int이기 때문에, 어떤 숫자를 넣든간에 int로서의 값의 의미가 달라진다
    // 그러나 200보다 큰 값을 넣지 않는다면, 어떤 숫자를 넣든 비교 결가는 같다
    // 이 이야기는 같은 비교 결과를 내는 int comp_1의 값이 무궁무진하다(경우의 수가 많다)
    // 비교 연산자는 "정확한 경우의 사례"를 찾아내기에는 부적절하다(조건문으로 치면 switch하고 궁합이 안 좋다)
    // 반면에 다양한 사례를 짧은 연산으로 줄여서 정확하게 기준을 제시하기에 매우 좋다(조건문으로 치면 if와 찰떡궁합)

    // 비교 연산자 실제로 더 알아보기

    compare = comp_1 > comp_2; // > : 왼쪽이 오른쪽보다 크다
    std::cout << compare << std::endl;

    compare = comp_1 >= comp_2; // >= : 왼쪽이 오른쪽보다 크거나 같다
    std::cout << compare << std::endl;

    compare = comp_1 < comp_2; // < : 왼쪽이 오른쪽보다 작다
    std::cout << compare << std::endl;

    compare = comp_1 <= comp_2; // <= : 왼쪽이 오른쪽보다 작거나 같다
    std::cout << compare << std::endl;

    compare = comp_1 == comp_2; // == : 왼쪽이 오른쪽과 같다(같은 것이 맞다)
    std::cout << compare << std::endl;

    compare = comp_1 != comp_2; // != : 왼쪽은 오른쪽과 다르다(같은 것이 아니다)
    std::cout << compare << std::endl;

    // -----------------------------------------

    // 위 연산자까지는 실전에서 매우 자주 쓰는 매우매우 중요한 코드
    // 위우는 것 이상으로 필요할 때 마음대로 쓸 수 있어야 하는 코드

    // 아래 연산자는 꼭 이론적으로 외워야 할 필요는 없습니다
    // 일부 예외를 제외하면 꼭 여기저기 써야 할 필요도 없습니다 → 적어도 게임 개발에서는
    // 그런데.....그런데도 불구하고 알아두면, 적절하게만 쓰면, 매우 매우 매우 유용합니다
    
    // .....경우에 따라 우리가 이 코드를 중 일부를 쓸 수 있습니다(알든 모르든)

    // {} : 범위 연산자의 일종. 그런데 연산에 쓰지 않습니다
    // 이 연산자의 역할은 "코드의 수행 범위"를 나타냅니다
    // {} 안에 있는 코드를 먼저 수행하거나, {} 안에서 코드가 끝나야 기능이 끝나는 것으로 칩니다

    // # : 처리 연산자라고도 하지만, 보통 # 뒤에 오는 명령어까지 포함하여, "사전 처리 명령어" 혹은 "전처리기"라고 부릅니다
    // # 뒤에 다양한 명령어를 붙이면, C++언어를 읽기 전에 먼저 주요 부가 기능을 수행하거나, 미리 읽어들입니다
    // 매우 많은 명령어가 있지만, 그 중에 우리도 알아둬야 할 *매우 중요한 것 몇가지*가 있습니다
    // 그 중 대표적인 사례가 : #include <iostream>

    // 삼항 연산자 : 사실은 조건문의 일종입니다만, 연산식으로 표현되다 보니 연산자로 취급하는 경우가 더 많습니다

    bool tri; // bool 변수 선언만
    tri = (1 > 3) ? true : false;

    int amugena; // 아무거나 숫자 하나 선언

    amugena = (100 < 1000) ? 999 : 3489754;

    std::cout << tri << std::endl;
    std::cout << amugena << std::endl;

    // 삼항 연산자의 구조
    // 왼쪽 변수 = (조건) ? 참결과 : 거짓결과
    // 왼쪽 변수 : 옵션. 오른쪽 연산식의 결과를 저장하기 위한 변수
    // 조건 : bool로 결과를 표현할 수 있는 조건 상황
    // ? : "이 조건이 맞는지를 보고, 각 결과에 따라 최종값을 지정하겠다"는 뜻의 연산자(삼항 연산자의 핵심)
    // 참결과 : 조건이 참일 경우 적용될 결과(반드시 "true"라는 값일 필요는 없다)
    // 거짓결과 : 조건이 거짓일 경우 적용될 결과(반드시 "false"라는 값일 필요가 없다)

    // ---------------------------------
    
    // 자료형 지정(casting, "형 변환"이라고도 한다)

    // (자료형이 이미 정해져 있는) 변수를 호출할 떄, 일시적으로 다른 자료형이 것처럼 바꾸어 쓸 수 있도록 하는 것

    // 대표적인 사례 : 소수를 내려서 표현하기(=소수점 밑으로 버리기)

    float pointed = 1.2345f; // 소수
    
    std::cout << pointed << std::endl; // 소수를 출력하면 소수가 나온다
    std::cout << (int)pointed << std::endl; // 소수를 호출했는데, 정수처럼 출력

    // 자료형 지정 방법 : 변수명 앞에 ()를 붙이고, () 안에 참조 하려는 새 자료형을 넣으면 된다

    int inte = 100; // 정수
    // (float)inte; // ← 정수지만 소수처럼 쓰는 것(이 경우는 큰 의미는 없지만.....)

    // 다른 대표적인 사례 2 : 문자의 코드(컴퓨터가 이해하는 문자의 순번)을 확인하기

    char ch = 'q'; // 여기에 문자를(영어, 숫자, 연산자) 바꿔가면서 확인 가능
    std::cout << (int)ch << std::endl; // ch가 정수로 변환되었을 때 몇인지 확인 가능

    // → 애초에 char라는 자료형 자체가 int 데이터를 문자 코드로 계산해서 문자로 출력
    // → 그래서 당연히 순서를 거꾸로 해서 char를 int로 출력할 수도 있는 것

    // 형 변환도 외워야 할 필요는 없는데, 좋든 실든 알든 모르든, 매우 빈번하게 쓰는 시정ㅁ이 있다
    // 미리 익숙해집시다

    // ---------------------------------

    // 별도 예습 + 오늘의 과제

    // 오늘 과제의 목적 : 외워주세요x "이런 것도 있습니다"

    // 오늘의 과제 : (bitwise)비트 연산자 / (shift, 이동)시프트 연산자 / 이동 연산자(모든 같은 대상 지칭)
    // .....에 대해서 찾아보시고, 텍스트 파일이나 파일로 필기해서 카페에 올려주세요
}