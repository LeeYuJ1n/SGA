#include <iostream>

int main()
{
    // 총복습 겸 보강 : 변수

    // 변수의 프로그램밍 내 정의 : 컴퓨터의 기억 공간 어느 곳에자리를 정해서 이름과 데이터(개발자 마음대로)를 부여한 것
    // → 수학에서 값이 마음대로 변하는 수(변수)와 닮아서 변수라고 부른 것

    // 변수의 문법적 구조
    // 1. 데이터의 유형(종류)를 표시 : 이를 자료형이라고 한다
    // 2. 해당 데이터를 지칭할 이름을 표시 : 이를 변수명이라고 한다
    // 3. 해당 이름으로 불릴 진짜 데이터를 표시 : 이를 값이라고 한다

    // 변수의 가장 단순한 사례
    int a = 1;
    // int : 이 변수가 정수임을 뜻하는 코드
    // a : 변수명
    // 1 : 값
    // → 이 다음에 a라고 코드에서 부르게 됨면, 이는 곧 1이라는 정수를 뜻한다는 의미

    // 변수의 특성 : 수정 가능하다(그래야 변수니까)
    a = 10;
    // → 이 다음부터는 a라고 코드에서 불렀을 때 1이 아닌 10이라는 정수를 뜻할 것이다

    // 변수를 작성하면 컴퓨터는 이후부터 해당 이름의 변수를 기억하게 된다
    // 
    // 기억만 해서는 쓸모가 없고, 변수는(변수 아니라 무슨 코드든) 불러서 써야 의미가 있다

    // 변수를 부르는 법 : 그냥 변수명을 호출
    a; // ← 변수를 부른 것(물론 개발자 입장에서는 눈에 아무 것도 안 보이지만)

    // 변수를 부름과 동시에 출력까지 하는 사례
    std::cout << a << std::endl;
    // std라는 코드 집합 속의 cout 명령러응 써서 a라는 데이터(즉 10이라는 숫자)를 모니터에 표시

    // 변수의 자료형 종류와 주요 특성(필요한 경우)

    int i_1 = 2000000000; // int : integer(정수)의 첫 글자

    // int를 사용할 때 취급 가능한 데이터 범위
    // (대략) -20억대 ~ 20억대 : 구체적으로는 16진수로 FFFFFFFF가 되는 숫자..를 각각 반으로 나눠서 -, +로 계산한 범위
    // 다른 말로, int가 컴퓨터로부터 부여받는(컴퓨터에서 차지하는) 메모리의 크기는 : 16진수 8개짜리, 혹은 "4바이트"입니다(1바이트가 16진수 2자리 크기)

    std::cout << i_1 << std::endl;

    // int에도 종류가 여럿 있다(일반적으로 게임 개발에서 자주 쓰이지 않을 뿐)
    short int i_2 = 100000;
    // short : int의 일종이지만, 취급 데이터 범위가 좁은 것
    // (대략) -3만대 ~ 3만대 : 구체적으로는 16진수 FFFF 가 되는 숫자를 반으로 나눠 -, +를 계산한 것
    // → 2바이트

    std::cout << i_2 << std::endl;

    //-------------------------------------

    long int i_3 = 3000000000;

    // long : int의 일종이고, 취급 가능한 데이터 범위가...사전적으로는 "긴"것
    // 그러나 실체는 int와 취급 범위가 똑같다 : long int = int, 똑같은 자료형

    std::cout << i_3 << std::endl;

    // -------------------------

    // int가 long을 대체하면서 추가된, long 보다 더 긴 숫자를 취급하기 위한 자료형

    long long int i_4 = 3000000000;

    // long long int : long보다 더 큰 범위를 다루기 위해 만들어진 int
    // 구체적으로 표현해서 FFFFFFFFFFFFFFFF를 각각 반으로 나눠서 -, +로 계산한 것
    // → 8바이트

    std::cout << i_4 << std::endl;

    // int를 포함해서, 숫자를 다루는 자료형은 한 가지 특성이 있다 : 음수를 다룰 수 있다는 것

    // 그래서 int 혹은 다른 숫자 자료형엦 지나치게 큰 숫자를 입력 했을 때 -가 표현된 것
    // 즉 0부터 시작된 숫자가 해당 자료혀잉 감당 가능한 최대치를 한 번 찍고, 다시 처음으로 돌아가서 쭉 숫자가 매겨진 것
    // 이런 현상을 데이터 넘침, 혹은 변수 넘침(오버플로우)이라고한다

    // 숫자를 다루는 자료형에서, 경우에 따라 음수가 필요없는 경우도 있다
    // 이런 경우, 음수를 계산하지 않고 자료형 범위 전체를 양수로 쓰게되면 다를 수 있는 데이터 범위가 늘어나서...
    // 이 때, 자료형 앞에 unsigned를 붙여주면 음수를 계산하지 않고 양수만 계산한다

    unsigned int ui_1 = 3000000000;
    unsigned short int ui_2 = 1000000;
    unsigned long int ui_3 = 3000000000;
    unsigned long long int ui_4 = -1; // unsigned를 입력하고 음수를 할당할 경우?

    std::cout << ui_1 << std::endl;
    std::cout << ui_2 << std::endl;
    std::cout << ui_3 << std::endl;
    std::cout << ui_4 << std::endl;

    // ----------------------------------
    
    // 소수는 int와는 자료형의 이름, 유래, 작동 방식이 조금 다르다

    // 가장 단순한 소수의 예
    float b = 1;
    float c = 1.1f;

    // float : 소수를 의미하는 C++의 자료형 이름
    // = 정확한 이름은 "부동 소수점 자료(floating point number)" 혹은 정밀도 표현 변수(precision number)라고 합니다

    // float으 특징 : 아주 작은 소수부터, 아주 큰 수까지 취급 가능
    // 이유 : 소수점의 위치 혹은 지수의 규모를 전담하는 바이트가 따로 있기 때문(그래서 부동=정해지지 않은 소수점)

    // float의 사용상 팁 : 소수점이 있을 경우 숫자 뒹 f가 붙으면 연산에 유리
    // 반면 소수점이 없는데 뒤에 f가 붙으면 (C++ 경우) 오류가 난다
    // (다른 언어는 각각 또 다를 수 있다. f가 무조건 붙어야 한다거나, 없어도 된다거나...)

    // float은 4바이트(int와 똑같다)

    float b_1 = 3000000000;
    float b_2 = 30000000000;
    float c_1 = 0.00000001f;

    // 극단적으로 큰 숫자, 혹은 극단적으로 정밀한 숫자(작은 수 + 긴 소수좀)를 입력하면
    // float은 지수 표기법으로 해당 숫자를 표시한다
    // 이런 표기법을 이용해서 어쨌든 오버플로우 없이 int보다 오히려 큰 숫자를 감당할 수있다
    // 그래서 정밀도 표현 변수인 것

    std::cout << b_1 << std::endl;
    std::cout << b_2 << std::endl;
    std::cout << c_1 << std::endl;

    // float도 unsigned가 적용 가능

    // C++에서는 floatrhk unsigned가 조합되지 않는다

    // unsigned float err = -1; → C++에서는 이러면 오류

    // -------------------------------------------------------

    // 소수 자료형 2 : double
    
    double d = 2.2;

    // double : "두 배로 정밀한 변수 " = float, 혹은 정밀도 변수의 바이트가 두 배라는 뜻
    // = 다룰 수 있는 숫자도, 소수점 길이도 모두 float의 두 배 = 다른 이름으로는 "배정밀도 변수"

    // double 사용사으이 특기사항 : 소수 뒤에 f나 d를 안 붙여도 된다(float이 만들어진 뒤에 프로그래밍 언어에서 각잡고 만들어낸 개념)

    std::cout << d << std::endl;

    // ---------------------------------------------------------

    // 문자 자료형 : char(케어, 혹은 '차'), character(문자)의 첫 네글자를 따서 자료형 이름이 정해졌다

    char ch_1 = 'A';
    char ch_2 = 'B';
    char ch_3 = 'C';
    char ch_4 = 'D';
    char ch_5 = 'E';

    std::cout << ch_1 << ch_2 << ch_3 << ch_4 << ch_5 << std::endl;

    // char에서 취급 가능한 데이터 범위 : 0부터 255(1바이트 int)가 대입 가능한 문자 한 개
    // 
    // 먼저 char를 컴퓨터가 이해하는 방식을 알아야 한다
    // char에서 초기화한 데이터 위에 마우스 커서를 올려보면 숫자가 나온다
    // → char의 실체는 int, 즉 int로 정해진 문자 코드를 컴퓨터가 해석해서 문자로 바꾸고 출력
    // 그리고 char는 문자 하나만 입력할 수 있다 : 문자 두 개를 입력하면 첫 번째 문자가 무시된다
    // 다시 말해, char는 1바이트짜리 아주 작은 int

    // 다르게 표현하면, char와 int는 다루는 숫자가 아주 작다면, 서로 교환해서 표시할 수도 있다
    // C++이나 몇몇 게임 엔진 등에서 유용하게 쓸 수 있는 깨알 팁(당장은 말고 나중에 기억나면 좋다!)

    // ---------------------------------------------------------

    // 참과 거짓을 가르는 논리 자료형
    // 개념을 발명한 개발자 불(bool)의 이름을 기려서 bool 변수라고도 한다

    bool _true = true;
    bool _false = false;

    // true는 참, false는 거짓, bool는 값이 이것뿐이다

    std::cout << _true << std::endl;
    std::cout << _false << std::endl;

    // 코딩에서는 true, false지만 출력하면 1, 0이 나온다
    // 변환하기에 따라서, 혹은 경우에 따라선 변환을 딱히 안 하더라도....
    // bool 변수는 그 자체로 int와 대응하기 좋다
    // int로 치면 0은 false, 0이 아닌 모든 숫자가 true가 된다

    _true = false;
    _false = true;

    std::cout << _true << std::endl;
    std::cout << _false << std::endl;

    // (다른 변수도 마찬가지지만) bool 변수에서 중요한 건 변수의 이름이 아니라 값
    // 변수명이 true든 아니든 값이 false면 거짓이고, 값이 true이 참이다
}