#pragma once

class ModelInstancing : public Model
{
    // 현재 애니메이터 구현의 약점 : 텍스처는 그렇다쳐도, 정점 정보와, 뼈대 정보, 움직임 정보까지
    // 모든 출력에 관계한 기초 데이터를 일일이 파일에서 읽은 후 별도로 생성해서 재생한다는 것

    // -> 객체가 많아지면 거의 그 객체의 구현 수만큼 컴퓨터가 부담을 떠안게 된다

    // -> 해결 방안 : 한 씬에 한 종류의 캐릭터가 여럿 나올 때, 해당 캐릭터를 구성하는 기초적인 요소
    //    (정점, 어떤 동작이 있는지, 어떤 뼈대를 가졌는지...)들을 한 군데에 저장하고,
    //    만들어진 실제 객체는 해당 실체만이 가지는 고유 정보와 (트랜스폼 정보나, 내부 데이터 몇 개)    //    다른 객체와 공유 가능한 공통 정보를 (생김새, 텍스처, 동작, 뼈대) 하나로 합쳐서  구현하는 것
    //    그러면 구현에 필요한 컴퓨터의 연산을 상당히 줄일 수 있게 된다

    // 모델, 혹은 애니메이션의 생성 후 관리법 (Animation Instacing, 애니메이션 인스턴싱)

    // * 같이 이해하면 좋은 용어
    // 1. 드로우 유닛 : 객체 하나를 그리기 위해 필요한 연산의 단위. 정점, 뼈대, 가중치, 매티리얼 등을 통칭
    // 2. 드로우 콜 : 컴퓨터가 단위 시간당 드로우 유닛을 받은 수. 이게 너무 높으면 컴퓨터의 사양이 높아진다(앱이 느려진다)

    // -> 애니메이션 인스턴싱을 다르게 표현하면 드로우 유닛을 공유시켜, 드로우 콜을 줄이는 기법

public:
    ModelInstancing(string name);
    ~ModelInstancing();

    void Update();
    void Render();
    void GUIRender();

    Transform* Add();

private:
    // 트랜스폼들을 미리 벡터로 모아놓기
    vector<Transform*> transforms;
    InstanceData instanceDatas[MAX_INSTANCE]; // 추가된 구조체 : 인스턴스 데이터
                                              // 내부 데이터 : 공간 정보(현재 형상) + 인덱스 (몇 호 인스턴스)

    // 메쉬가 아니라 정점만의 정보를 따로 버퍼로 빼놓는다
    VertexBuffer* instanceBuffer;

    UINT drawCount = 0;
};