#include <iostream>

// 확인용 함수
void Check(int input)
{
    std::cout << &input << std::endl; // 변수명 앞에 & 붙이기
    // & 표시 : 변수명 앞에 붙이면 그 변수가 있는 메모리 주소를 알 수 있게 해준다
    input = input + 10;
}

// 포인터 확인용 함수
void CheckByPointer(int* inputAddr) // 매개변수로 input할 숫자...의 포인터(메모리 주소)
{
    *inputAddr = *inputAddr + 100;
    // (매개)변수명 앞에 *를 붙임 : 해당 메모리 주소에 있던 원래의 값을 호출
    // 변수가 아닌, 메모리 주소를 기준으로 *"딱 그곳"의 값을 고치겠다
}

void CheckByPointer_2(int* inputAddr)
{
    *inputAddr = *inputAddr + 50;
}

void CheckByPointer_3(float* inputAddr)
{
    *inputAddr = *inputAddr + 50;
}

int main()
{
    // 지난 상황 : 함수에서 매개변수를 썼는데, 매개변수 그 자체에 변화를 주면?
    //             매개변수가 된 실제 변수에는 변화가 없다

    // 예 : 공격 함수를 했는데 표적 체력이 그대로예요

    // 추가로 생각해볼 점 : 문자열은 왜 수정이 안 될까?
    // char name[17] = "이름은여덞자까지";
    // name = "이름을바꿔봅시다"; // ← 오류!

    // 위 사례에서 각각 변수 ㅅ수정이 안 되는 이유 2가지

    // 이유 1. C_++에서 변수를 다루는 방식의 특징

    // C++은, 변수를 수정해야 할 때, 호출했을 때, 기타등등 사용할 때...
    //  그 변수 자체를 쓰지 않는다 = 가본을 만들어서 그 사본을 쓴다

    // - 변수를 매개변수로 넣으면 → 변수의 사본을 만들어서 그걸 매개변수로
    // - 변수를 수정하려고 하면 → 별도의 공간에 임시 데이터를 만들어서 그걸로 수정

    // 이유 2. ?????

    // -------------------------------------
    
    // 변수가 C++에서 다뤄질 때 사본을 통해 다뤄진다 것을 직접 먼저 확인해보자

    // 그러기 위해서는 변수가 컴퓨터에서 자리를 잡은 위치를 알아야 한다
    // → 이 위치를 메모리 주소라고 한다(데이터가 기억된 장소)

    // 위에 확인용 함수를 만든 후, 변수를 넣어보자

    int a = 100; // 확인용 변수

    std::cout << a << std::endl; // a의 데이터 확인
    std::cout << &a << std::endl; // a가 지금 컴퓨터 안에서 차지한 위치
    // & 표시 : 변수명 앞에 붙이면 그 변수가 있는 메모리 주소를 알 수 있게 해준다

    Check(a); // 체크라는 함수 안에 매개변수 a 넣기
    // 체크 함수 안에도 &input이 있으니 &a와 위치가 같은지 다른지 확인 가능
    // 실행하면 위에서 작성된 변수 a와 함수 안에 매개변수로 쓰인 a가 다르다는 것을 확인 가능

    std::cout << a << std::endl; // 함수 실행 후 a의 데이터 확인

    // * 변수가 실제로 컴퓨터의 어느 메모리 주소에 들어가는지는 실행 시마다 다르다
    // 따라서 아주 특수만 문법을 쓰지 않는 한, 기계어를 쓰지 않는 한
    // 변수가 위치할 메모리 주소(위치)를 우리가 직접 통제할 수는 없다
    
    // * 다만 어디가 됐든, 변수는 컴퓨터에서 반드시 메모리 주소를 가진다는 것
    // 변수명 앞에 &를 붙이면 그 메모리 주소는 우리가 매번 알 수 있다는 것
    // 이 두가지가 실제로 중요하다

    // 변수가 앱 실행 시마다 메모리 주소를 반드시 갖게 된다면...
    // 변수를 쓰기보다, 
    // "변수가 지금 있는 메모리 주소"를 알아내서(알아낼 수 있으니까)
    // *그 위치에 있는 (뭐가 됐든) 거기의 실제 데이터*를 조작한다면?

    // 그렇게 하면 사본을 거치지 않고 변수를 직접 바꿀 수 있지 않을까?

    // 이것이 c와 c++에서 변수의 사본처리를 보완하기 위해 만든 추가 문법
    // : 메모리 주소에 대한 직접 접근
    // : 메모리 주소에 대한 지정 호출
    // = 호출을 위한 지정 연산자, "포인터"(pointer)

    // -------------------------------------------

    // 포인터 연산자 : 기호로는 * 를 쓴다

    // 1. 변수 작성 시에 변수명 앞, 혹은 자료형 뒤에 붙이면 해당 변수는 데이터가 아니라 "어떤 메모리 주소"를 실제 데이터로  받는 상태가 된다
    int* ptr; // 포인터를 사용한 변수

    // ptr = 10; // 포인터를 사용한 변수는 본재의 데이터를 받지 않는다
    // int도 정수를 안 받고, float도 소수를 안 받는다

    ptr = &a; // 포인터를 사용한 변수는 해당 자료형의 어떤 데이터가 들어갈(혹은 들어간) 메모리 주소를 값으로 받는다

    // 포인터에 직접 주소를 넣을 수 있는가?
    
    // ptr = 0000ffffff; // 수동으로 메모리 주소를 넣을 수는 없다
    // 포인트를 쓴 변수는 값으로 "그 자료형 데이터가 지금 있는 주소"를 받아야 한다
    // int와 포인터가 쓰인 변수 : 지금 int가 데이터가 있는 주소 값이어야 한다
    // float과 포인터가 쓰이면 : 지금 float이 있는 주소가 값이어야 한다

    // 예시용 변수
    int b = 200;
    float c = 300;

    ptr = &b; // a가 있었던 주소에서 b가 있는 주소를 포인터 변수 값 바꾸기
    // ptr = &c; // c, 즉 소수가 있는 주소는 int 포인터 변수의 값이 될 수 없다

    // 다시 한 번 확인
    std::cout << &b << std::endl; // b라는 정수가 컴퓨터에서 차지한 자리
    std::cout << ptr << std::endl; // ptr이라는 변수의 값 = b라는 정수가 컴퓨터에서 차지한 자리

    // b가 실제로 컴퓨터의 어디에 있는지는 앱 실행 때마다 매번 바뀌지만
    // ptr이라는 변수는 b의 위치를 항상 똑같이 추적할 수 있으니까 문제가 없다

    // 그러므로 이제 &b, 혹은 ptr만 있으면 b라는 변수의 값을 언제든지 호출 가능
    
    // ---------------------------------

    // 2. 포인터를 사용해 (운래 불렀어야 할) 값을 호출하기

    // 포인터 변수를 호출할 때(작성 말고 사용) 변수명 앞에 *를 붙이면
    // *해당 포인터 변수의 값 = 원래 변수의 메모리 위치에*에 있었던 실제 데이터를 부르라는 뜻이 된다

    // 확인 cout : 위에서 만든 a와 ptr을 사용
    ptr = &a; // ptr을 &a로 다시 수정

    std::cout << a << std::endl; // a의 값 출력
    std::cout << &a << std::endl; // a가 있는 위치
    std::cout << ptr << std::endl; // ptr이라는 포인터 변수의 값 = a가 있는 위치
    std::cout << *ptr << std::endl; // a가 있는 위치에 있었던 실제 데이터 = a의 값

    std::cout << *&a << std::endl; // ptr의 값이 &a니까, &a앞에 *가 붙어도 똑같다 : a의 값

    // ------------------------------

    // 포인터를 활용한 변수 호출과 수정

    // main위에 / 혹은 선언 후 밑에 확인용 함수 작성

    // 포인터 확인용 함수로 변수 a의 값을 수정

    CheckByPointer(ptr); // ptr = a의 주소를 매개변수로 사용

    std::cout << a << std::endl; // 본래의 값 = a의 값이 바뀌었는지 확인

    // 포인터를 매개변수로 사용하면 다른 함수에서도 본래 변수의 값을 바꿀 수 있다

    // 포인터만이 아니라 &+변수명, 즉 주소 호출도 매개변수로 쓸 수 있다

    CheckByPointer(&a); // ptr = &a니까 ptr넣으나 &a넣으나

    std::cout << a << std::endl; // 본래의 값 = a의 값이 바뀌었는지 확인
    
    ptr = &b;

    CheckByPointer_2(ptr);

    std::cout << ptr << std::endl;
    std::cout << *ptr << std::endl;

    float* ptr_1;

    ptr_1 = &c;

    CheckByPointer_3(ptr_1);

    std::cout << ptr_1 << std::endl;
    std::cout << *ptr_1 << std::endl;

    // ----------------------------------------

    // 포인터를 어떻게 이해하고 응용해볼 수 있는가

    // 예시용 배열
    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    // 배열을 출력한다면
    std::cout << arr[0] << std::endl; // 먼저 배운, 일반적인 출력방식
    std::cout << arr[1] << std::endl;
    std::cout << arr[2] << std::endl;
    std::cout << arr[3] << std::endl;
    std::cout << arr[4] << std::endl;
    std::cout << arr[5] << std::endl;
    std::cout << arr[6] << std::endl;
    std::cout << arr[7] << std::endl;
    std::cout << arr[8] << std::endl;
    std::cout << arr[9] << std::endl; // 10번 출력

    std::cout << arr << std::endl; // 배열의 이름만 출력 대상으로 삼으면?
    // 이전에는 "이렇게 작성하면 의도한 결과가 안 나온다"고 했던 출력

    // → 배열을 이름으로만 출력하면 : 그 배열의 메모리 주소가 나온다(C++에서)

    // 여기서 추측 가능한 사실 : 배열의 이름은 포인터다

    // ---------------------------------------

    char name2[17] = "여덟글자짜리이름"; // ← 문자열도 배열
    name2; // ← 이것도 포인터

    // name2 = "새이름";
    // 여기서 문제가 생기는 이유도 배열의 이름이 포인터인 것과 연관
    // 1. 변수 자체도 사본이지만
    // 2. 배열의 이름은 포인터인데, 수정하려는 값은 문자열이라서(형식이 안 맞아서)

    // *name2 = "뉴이름"; // 배열의 이름에 *을 붙이면 값을 호출하는데, 이러면 문자열 수정이 가능한가?
    // .....옛날에는 됐다. 하지만 적어도 VS2012가 나올 때쯤부터는 불가능해졌다
    // C++이 문자열이라는 변수 형식에 유독 예외를 많이 두는 것 같다

    const char* name3 = "가가가가가가"; // 이런 식으로는 작성은 할 수 있는데
    // 위 변수는 또 수정이 안 된다(다음 번에 설명)

    // 그리고 문자열이 포인터라면
    std::cout << name2 << std::endl; // ← 이건? 왜 메모리 주소가 아닐까?
    // C++이 문자열에 정말 예외를 많이 둔다

    // ----------------------------------------

    // 대신 포인터와 같은 배열의 이름들(= 또 포인터)를 이용해서
    // *문자열의 값을 자유 수정은 아니어도, 지정은 가능하다

    // 예시
    char word1[9] = "사과";
    char word2[9] = "배";
    char word3[9] = "귤";
    // 이렇게 문자열 변수를 미리 만들어놓고 

    char* wordReal = word1; // 문자의 포인터 값을 다른 포인터(=문자의 배열의 이름)로 바꾸는 건 가능

    std::cout << wordReal << std::endl; // 출력

    wordReal = word2; // 배열의 이름 값을 = 메모리 주소를 바꿔보자

    std::cout << wordReal << std::endl; // 출력

    wordReal = word3; // 배열의 이름 값을 = 메모리 주소를 바꿔보자

    std::cout << wordReal << std::endl; // 출력

    // 이런 방식으로
    // 1. 하나의 포인터 변수를 활용해서 다양한 실제 변수의 값을 호출할 수 있다
    // 2. 문자 포인터 변수를 활용하면(사전에 만든) 다양한 문자열 데이터를 바꿔서 적용할 수도 있다
}