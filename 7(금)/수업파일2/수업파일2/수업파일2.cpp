#include <iostream>



int main()
{
    // 꼭 필요하진 않은데 나름 알면 쓸 데는 있는 것들

    // "sizeof" : 명령어, 혹은 연산자
    // : 대상으로 지정된 데이터의 메모리 크기를 바이트로 표현해주는 것
    int a = 1; // 정수 변수
    sizeof(a); // a라는 정수의 바이트 크기

    std::cout << a << std::endl;
    std::cout << sizeof(a) << std::endl;

    // sizeof는 실행하면 항상 정수, 항상 양의 정수, 그리고 인식이 모호한 경우를 빼면, C++의 모든 데이터가 대상이므로 감당 가능한 숫자가 매우 크다

    // -------------------------------------------------

    // sizeof를 언제 응용할 수 있는 방법
    int arr[5] = {1, 2, 3, 4, 5};
    int arr2[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    std::cout << sizeof(arr) << std::endl; // 20 : 정수 하나의 크기 4에 배열에 원소 개수 5를 곱한 것 : 배열 전체의 크기
    std::cout << sizeof(arr2) << std::endl;

    std::cout << sizeof(arr) / 4 << std::endl; // 4로 나누는 이유 : int의 sizeof가 4이므로
    std::cout << sizeof(arr2) / 4 << std::endl;

    // 이 방식을 쓰면 배열의 길이를 호출 시에 쉽게 판단할 수 있다
    // → 매개변수 등을 써서 배열을 출력하려는데, 매개변수로 넣을 배열들이 크기가 제각각일 때 써먹으면 좋다

    // --------------------------------------------------

    char name[9] = "compute"; // 8글자짜리 문자열

    std::cout << sizeof(name) << std::endl; // 적혀 있는 글자 숫자가 아니라, 작성 시에 지정된 배열의 크기가 나온다

    // → 문자 등을 배열을 다 채우지 않아도 딱 배열의 크기가 나오고
    // → 문자열은 배열을 다 채워도 어차피 배열 크기만큼 값을 넣을 수가 없다(문자열 마지막 칸은 언제나 "문자열 끝이라는 뜻의 특수문자"로 고정)

    // 문자열을 sizeof의 대상으로 활용하기에는 경우에 따라 애매한 때도 있다(주의)

    // ------------------------------------------------------

    // 포인터를 이용한 이중배열
    int* aarr[2] = {arr, arr2}; // 위에 만든 배열 두 개를 원소로 한 이중배열

    std::cout << sizeof(arr) << std::endl; // arr이라는 배열의 크기
    std::cout << sizeof(aarr[0]) << std::endl; // aarr의 0번째 순번이 arr이니까, 역시 arr이라는 배열의 크기?

    // 배열을 있는 그대로 쓸 때와, 포인터로 만들어진 다른 배열의 원소로 쓸 때 sizeof는 결과값이 달라진다(주의)

    // -----------------------------------------------------

    // 명시적으로 만든 깡 이중배열
    int da[3][4];

    std::cout << sizeof(da[0]) << std::endl; // da[0][0]부터 da[0][3]까지를 포함하는 분류

    // 명시적으로 확실하게 만든 이중배열은 sizeof를 실행했을 때, 결과값을 있는 그대로 출력

    // ---------------------------------------------------------

    // 위 과정들을 통해서 알 수 있는 sizeof 연산의 원리

    // 기록된 변수의 메모리 시작부터 그 변수로 구분된 메모리가 연속을 마치는 곳까지 가서 크기를 계산하는 것
    // 배열 전체가 한 번에 만들어질 때는 그 크기만큼 연속된 자리가 처음부터 할당되었기 때문에 크기도 정확하게 볼 수 있는 것

    // 단독 변수, 혹은 정적으로(정확하게 그 크기만큼) 만든 배열의 크기를 알고 싶을 때, 유용한 연산

    float fa = 1;
    short sa = 1;
    double ba = 1;
    long long lla = 1;

    std::cout << sizeof(fa) << std::endl;
    std::cout << sizeof(sa) << std::endl;
    std::cout << sizeof(ba) << std::endl;
    std::cout << sizeof(lla) << std::endl;
}