#include <iostream>
#include <conio.h>

int main()
{
    int a = 10; // 오늘의 비교용, 실험용 정수 변수(기준)
    int b = 30;

    // #포인터
    // #상수

    // 이 둘을 합쳐서... #포인터상수 #상수포인터

    // 쓰는 방법

    // 사례 1 : 상수포인터 → 상수로 가는 포인터(pointer to constant)
    //          만들어진 변수(포인터)는 수정할 수 있는 변수지만
    //          포인터의 대상(즉 본래의 변수)는 수정할 수 없게 하는 코드

    const int* pa1 = &a;
    // 한국인은 마침 const → *순서로 읽어서 상수 포인터라고 해도 된다(대신 이렇게 외우면 나중에 헷갈림)

    // 포인트를 값과 메모리로 호출해서 수정을 시도
    pa1 = &b; // pa의 주소를 b로 교체(포인터 자체의 값을 바꾸기)
    *pa1 = 11; // 상수 수정으로 인한 오류 : pa1의 호출된 값을 11로 수정(포인터 대상의 값을 바꾸기)

    // ----------------------------------------------------

    // 사례 2 : 포인터상수 → constant pointer, 포인터 변수의 반대 개념
    //          지정하는 대상(본래의 변수) 바꿀 수 있지만,
    //          포인터의 값(메모리 주소)을 바꿀 수 없도록 하는 코드
    
    // 포인터 변수의 개념 : 포인터(pointer)는 프로그래밍 언어에서 다른 변수, 혹은 그 변수의 메모리 공간주소를 가리키는 변수를 말한다. 포인터가 가리키는 값을 가져오는 것

    int* const pa2 = &a; // const가 int* 뒤에 오는 것에 중의
    // * → const 순서로 읽어서 포인터 상수라고 해도 된다(정 어렵다면)

    // 포인트를 값과 메모리로 호출해서 수정을 시도
    pa2 = &b; // pa2의 주소를 b로 교체, 상수 수정으로 인한 오류
    *pa2 = 11; // pa2의 호출된 값을 11로 수정

    // ----------------------------------------------------

    // 사례 3 : 상수 포인터 상수(constant pointer to constant)
    const int* const pa3 = &a; // 앞뒤로 다 상수 붙이기
    
    // 아래 코드가 모두 상수 수정 시도가 돼서 오류로 결과가 나온다
    pa3 = &b; // 메모리 주소도 변경 분가능
    // *pa3 = 33; → 값도 수정 불가능

    // ----------------------------------------------------

    // 상수 포이너를 활용하는 사례

    // 1. 구조체를 하나 생각해봅시다
    struct Gujoche
    {
        int index; // 순번이 있고...
        const int id; // 식별번호도 있다고 생각해봅시다
    };

    // 위 구조체는 에러가 안 납니다(구조체는 범용을 중시해서, 값이 초기화가 안 돼도 컴퓨터가 넘어가줍니다)
    
    const int consta; // 만약 구조체 밖이었으면 초기화 못 한 상수는 오류의 원인

    // 2. 이 구조체로 구조체 변수를 만들어봅시다
    
    Gujoche gujo;

    // 여기서 구조체를 수정하려니 구조체 안에 있는 상수가 걸립니다(당장 윗줄 에러)

    gujo.index = 1;
    gujo.id = 10; // ← 이 "상수"를 수정 불가능

    // 그런데 이 구조체가 어떤 프로그램 내의 주체(예 : 게임 캐릭터)를 나타낸다면...
    // id가 이 안에 있으면 안 된다는 건 말도 안 됩니다

    // 3. 이럴 때 상수 포인터를 사용합니다

    struct Character
    {
        int rawID; // ← 수정할 수 있는 변수
        const int* id = &rawID; // ← 이게 호출할 대상, 진짜 id
        // 위줄은 상수니까 미리 값을 초기화부터 해줍니다

        // 그리고 이쯤에 개발자 주석을 남깁니다(혹은 rawID 직후에 남겨도 됩니다)
        // : rawID는 호출하지 말라고. id를 쓰라고.
    };
    // 캐릭터 변수를 만든 후 id를 호출합니다

    Character chara;
    chara.rawID = 100; // rawID를 한 번 정한 후...

    chara.id; // ← 그 뒤로는 id를 계속 호출하도록 합니다

    // 이 방법을 사용함으로써, 한 구조체를 공유하는 여러 캐릭터에게
    // 각각의 id를 부여하면서도 그 값을 상수로 이용할 수 있게 됩니다

    // 그런데... 누가 청개구리처럼 rawID에 기어이 또 접근을 한다면?

    chara.rawID = 100000;
    // 이 때, 오류를 내면서까지 접근을 막을 방안이 현재로서는 없다
    // → 그래서 이렇게 접근 불가여야 할 (그러나 적절한 순간에 수정은 할 수 있는ㄷ0
    //   그런 데이터에 대한 추가 보안의 필요가 발생
    
    // → 그에 대한 대처가 이번 주 강의의 주제

    // 다른 말로 : 상수 포인터도 데이터를 완벽하게 보호하진 못 합니다
    //            다만, 포인터와 상수만 가지고 데이터의 보안을 만들어낼 수 있다는 장점 덕분에
    //            구조체까지 쓰이는 프로그래밍 환경에서는 여전히 유용하게 쓰입니다

    // ------------------------------------------------------

    // 요약

    // 상수 포인터 : 상수 포인터는 가리키는 값을 수정할 수 없지만, 다른 주소를 가리키도록 수정 가능(주소 수정o / 값 수정x)

    // 포인터 상수 : 포인터 상수는 항상 같은 주소를 가리키며, 가리키는 값을 수정할 수 없습니다(주소 수정x / 값 수정x)

    // 상수 포인터 상수 : 포인터 자체가 수정될 수 없으며, 포인터가 가리키는 값 또한 수정될 수 없는 포인터(주소 수정x / 값 수정x)
}