#include <iostream>
#include "MyClass.h"

int main()
{
    // 1차 설명은 MyClass에서 진행

    // 여기서는 클래스를 사용하고 호출하고 수정하는 방법에 대해 설명

    // 클래스도 구조체처렁 그 자체가 진짜 데이터는 아니다
    // → 말하자면 설계도, 혹은 DNA, "특성과 성격"

    // 클래스가 프로그램에 나오려면 변수 혹은 구조체처럼 다시 선언 및 초기화가 되어야 한다

    MyClass mc; // ← 이렇게 선언해야 사용 가능

    // 그런데 이렇게 선언된 "데이터"를 지칭할 떄, 변수는 당연히 변수라고 불렀다
    // 구조체는 구조체 변수, 포인터는 포인터 변수, 배열은 배열이지만, 배열이란 이름 안에 "변수의 집합"과 "포인터"라는 뜻이 다 들어가 있다

    // 반면 클래스는? 안에 변수가 있긴 하지만, 클래스는 변수가 아니라 그 이상
    // 함수인가? 함수도 아니고 그 이상 → 그 모든 것의 종합

    // 그래서 클래스를 선언한 "데이터"는 변수라고 부르지 않고, "생성된 존재"라고 부른다
    
    // 다른 말로, "인스턴스"(instance)

    // 그리고 인스턴스의 원본인 클래스와, 다시 그 클래스로 만들어낸 인스턴스
    // 이 둘을 총칭해서 "객체"라고 한다(오브젝트)

    // --------------------------------------------------

    // 인스턴스를 사용하는 방법(=클래스를 실제 프로그램에서 사용하는 방법)
    // *우리가 "클래스를 프로그램에서 사용한다"고 하면, 십중팔구는 인스턴스

    std::cout << mc.xx << std::endl; // 변수 호출
    std::cout << mc.Mult(10, 3) << std::endl; // 함수 호출

    // 구조체에서 변수를 쓰는 것처럼 인스턴스에서 함수도 불러낼 수 있다

    /// 주의할 점 : public만 된다. private은 여기서 호출 불가능

    // std::cout << mc.a << std::endl;
    // std::cout << mc.f << std::endl;
    // std::cout << mc.id << std::endl;
    // ShowFloat(100000);

    // 다시 말해, 클래스는(이전까지의 문법과 달리( private 밑에 코드를 작성함으로써
    // 밖에서 해당 데이터를(변수든 함수든)호출도 수정도 아예 불가능하게 할 수 있다

    // 이렇게 함으로써 1. 자기 안의 데이터를 안전하게 지킬 수도 있고
    // (예 : 굳이 상수를 고집하지 않고도 id를 아무도 수정 못하게 할 수 있음)
    // 2. 쓰는  입장에서 골치 아프게 고민하면서 "쓸까 말까"를 판단할 필요도 없어진다
    // (안 보이는 데이터? 고치면 안 되니까 그랬겠지. 데이터가 보인다? 써도 되겠지)

    // 이렇게 해서 데이터를 안전하게 숨김과 동시에 편리하게 노출을 축소시키는 것
    // → 은닉(은닉성, data hiding) / 밀폐, 캡슐화(encapsulation)

    // ----------------------------------------------

    // 클래스와 인스턴스, 즉 은닉이 있는 개체에서 은닉된 정보를 어떻게 활용하는가

    // 1. 제일 쉽고 제일 정확한 활용법 : 안 쓴다
    // 2. 그래도 쓰겠다면 : 호출 전용 함수를 public에 하나 더 만든다

    // (클래스 헤더 참조)
    mc.CallshowFloat(45.34f);
    // 1. main에서는 CallShowFloat 함수 호출
    // 2. CallShowFloat 함수는 (그 클래스 안의) ShowFloat 함수 호출
    // 3. 최종적으로 ShowFloat 함수가 호출된 결과가

    // 2-1. 변수에도 비슷한 식으로 호출 전용 함수를 public에 만들어두면,
    // 수정은 할 수 없고 볼 수만 있는(마치 상수처럼 쓰는) 데이터를 만들 수 있다

    // (클래스 헤더 참조)

    std::cout << mc.ID() << std::endl; // 함수로써 호출만(그리고 열람만)

    // 3. (사실 현역들이 무진장 비추하는 방법. 그러나 본인들도 잘 쓴다)
    //    수정 전용 함수도 따로 하나 더 만들면 된다

    mc.SetID(98765);
    std::cout << mc.ID() << std::endl;

    // 은닉을 했다고 하더라도 쓰다 보면 데이터 수정 욕구가 생기는 게 개발자
    // → 이렇게 수정용 함수를 쓰게 되면 데이터 접근권은 매우 커진다

    // 이 때수정 전용 함수를 흔히 세터(Set~~~)로, (혹은 셋터, 세타)
    // 열람 전용 함수를 흔히 게터(Get~~~)로 부르게 된다 (혹은 겟터, 혹은 겟타)

    // 그런데 왜 비추하느냐? → 이유는 명쾌간단, "이럴 거면 클래스 왜 쓰냐?"
    // 수정도 되고 열람도 되는데 private에 코드 쓸 의미가 없다고 여기는 것

    // --------------------------------------------

    // 이런 방식으로, 클래스 안의 기능은 클래스 안에서만 호출 가능하고,
    // public은 예외로 밖에서 호출 가능하다는 차이를 이해하고 쓸 수 있으면

    // 클래스의 가장 기본적인 활용 방법은 모두 이해한 것

    // ---------------------------------------------

    // (내일 강의로 이어지기 위한) 클래스 데이터 활용 간단 팁

    // "이니시에이터" : 초기화 기능
    // public으로 작성, 자유 호출 가능
    // 다만 이름에서 느껴지는 특성상 꼭 필요한 경우가 아니면(예 : 처음 만들어진 경우)
    // 웬만하면 잘 호출하지 않게 된다

    // 이니시에이터의 목적 : 그 클래스의 모든 변수를 값을 할당하는 것
    // → 모든 변수의 대응하는 매개변수를 한 번에 받기도 한다
    // → 다소 보안상 위험하지만, 귀찮다는 측면에서 의외로 만들면 오용은 덜 되는 함수

    // 오늘 만든 클래스의 경우, 이니시에이터 작성 후 호출(작성은 헤더와 cpp에서)

    mc.Init(100, 200.4f, 200, 300); // 값을 새로 지정

    std::cout << mc.ID() << std::endl;
    std::cout << mc.Mult(20, 7) << std::endl;
    std::cout << mc.xx << std::endl;

    // 이렇게 이니시에이터를 만들면 다른 문법을 쓰지 않더라도
    // 같은 클래스에서 다른 인스턴스를 만들었을 때 서로 값을 다르게 줄 수 있다

    MyClass mc2;
    mc2.Init(111, 222.8f, 333, 444);
    std::cout << mc2.ID() << std::endl;
    std::cout << mc2.Mult(30, 7) << std::endl;
    std::cout << mc2.xx << std::endl;

    // 다만 이니시에이터 역시 결국은 보안에 문제가 있다는 게 바뀌진 않아서,
    // private이 좀 더 보호받을 수 있는 다른 문법이 같이 사용될 경우,
    // 해당 문법과 짝을 이루어서 더 안전하게 실행되도록 코딩되는 경향이 있다
    // (오늘까지는 public으로 쓰면서 인스턴스에 값 넣는 방법을 연습해봅시다)
}