#include <iostream>
#include <string.h>

using namespace std;

int main()
{
    // 문자열 part2 : C+에서 새로 생긴 복잡하고 유연한 문자열

    // C++에서는 char 외에 좀 더 유연한 문자열을 위한 별도의 클래스를 제공
    // → std::string

    std::string str; // ← 새로운 문자열 클래스. 사실살 "함수가 지원되는 자료형"이라고 봐도 무방

    char cf[9]; // 비교용 문자열, char 사용
    int a = 0;

    string strNP; // using namespace std와 같이 쓰면 std:: 생략 가능

    // std::string 클래스의 특징
    // 1. 클래스니까 자체로 지원되는 각 함수들이 있다
    // 2. (중요) 수정이 쉽다
    // 3. (더 더 중요) 일부 산술 연산자가 적용된다(모두는 아니고)

    // 요약 : 마치 다른 변수를 취급하는 것처럼 쉽게 수정, 조작 가능
    // → std::string 클래스가 너무 좋아서 이후의 언어부터는 그냥
    //   클래스도 아니고 자료형으로 쓰기까지 한다(기보 지원이란 뜻)

    // cf = "훈민정음"; ← char의 배열로 만든 문자열은 나중에 수정불가
    //strcpy()를 쓰면 "복제"는 가능

    str = "반갑습니다, 세상이여!"; // ← 오류를 내지 않고 수정 가능

    cout << str << endl; // 출력 가능 ? → 출력 가능!

    str = "반갑습니다, 여러분!"; // 한 번 정해진 값을 또 수정 가능
    cout << str << endl;

    // + 연산자 적요 ㅇ가능
    str = str + " 아니면 말고요";
    cout << str << endl;

    // 그러면 - 연산자는?
    // str = str - "아니면 말고요"; ← - 연산자는 적용 불가능

    // 문자열에 "곱하기"는 의미상 통하지 않으므로 *, /, %세 개는 논외

    // 추가 연산자 확인을 위해서 추가 변수
    string word1 = "abcd";
    string word2 = "wxyz";

    // string의 + 연산자는 같은 string끼리도 적용 된다
    cout << word1 + word2 << endl;

    // string에 <, >과 같은 산술, 비교 연산자도 적용 가능
    // 이 경우 비교 연산자의 의미 : 사전상의 순서가 된다
    cout << (word1 < word2) << endl; // 더 빨리 오는 단어일수록 순서가 빠르고(순번이 낮고) 따라서 true
    cout << (word1 > word2) << endl; // 더 늦게 오는 단어일수록 순서가 느리고(순번이 높고) 따라서 false
    
    // string에 ==, !=와 같은 논리, 비교 연산자고 적용 가능
    string word1a = "abcd";
    cout << ( word1 == word2 ) << endl;
    cout << ( word1 == word1a ) << endl;

    // 여기까지만 알고 써도 문자열의 마음대로 관리하는 데에 따르는 제약을 크게 벗어던질 수가 있다

   // ------ 그래서, 정말 중요한 최적화가 아니라면, 현실에서도 생각보다 string을 매우, 매우 자주 사용한다(코데, 게임개발...)

   // 이후의 언어에서 기본 지원되는 것이 괜히 그런 게 아닌 것

   // 그러니 이제부터는 필요하면 얼마든지 string 씁시다

   // --------------------------------------------------------

   // string이 클래스로 가지는 특성 : 내부의 함수들

   // 클래스 내에서 자체적으로 문자열을 추가 관리하는 함수를 제공
   
   // append : 문자열을 기존 문자열 뒤에 추가해주는 함수
   str.append(" 여러분은 어떠세요?");
   cout << str << endl;

   // push_back : 문자 하나를 기존 문자열 뒤에 추가해주는 함수. 빠르다
   str.push_back('!'); // 매개변수는 작은 따옴표(문자 하나)
   cout << str << endl;

   // pop_back : 기존 문자열에서 맨 뒤에 있는 문자 하나를 삭제하는 함수
   str.pop_back();
   cout << str << endl;

   // find : 문자열에서 매개변수로 지정한 문자열이 처음으로 검색되는 순번을 반환하는(찾아내는) 함수
   cout << str.find(",") << endl;

   // cin으로 문자열을 입력하는 것도 가능!
   cin >> str;
   cout << str;

   // replace : 문자열의 특정 위치를 다른 문자열로 바꿔주는 함수
   str.replace(0, 10, "반가워요우");
   cout << str << endl;
   // 첫 번째 0 = 교체를 시작할 순번(위치)
   // 두 번째 10 = 교체를 진행할 문자열의 길이(얼마나 바꿀 것인가)
   // 세 번째 = 기존 문자열을 이걸로 바꾸겠다는 뜻

   // substr : 기존 문자열에서 위치를 기준으로 특정한 분량을 따로 잘라내는 함수
   string str_sub;
   str_sub = str.substr(2, 10); // 서브 스트링
   cout << str_sub << endl;
   // 첫 번째 2 = 자르기를 시작할 순번
   // 두 번째 10 = 자르기를 진행할 분량(길이)

   // insert : 기존 문자열에서 위치를 기준으로 새로운 문자를 삽입하는 함수
   //          append와의 차이 : 이 함수는 중간에 끼워넣는다
   str.insert(0, "만나서 정말 ");
   cout << str << endl;
   // 첫 번째 0 = 삽입할 순번
   // 두 번째 문자열 = 삽입할 문구

   // erase : 기준 문자열에서 위치를 기준으로, 분량만큼 삭제하는 함수
   str.erase(12, 4);
   cout << str << endl;
   // 첫 번째 12 = 삭제를 시작할 순번
   // 두 번째 4 = 삭제할 분량, 삭제한 문자열 길이
   // * 두 번째 매개변수가 없으면 첫 삭제 순번 이후는 전부 다 지웁니다

   // at : 문자열의 지정된 문자(*1 바이트) 하나를 출력하는 함수
   str.at(2); // ← 특정 순번의 있는 문자 하나를 보여주는데...
   cout << str << endl; // ...한글이 짤려서 안 나온다

   // 비교용 문자열 3
   string comp1 = "aaaa";
   string comp2 = "bbbb";
   string comp3 = "aaaa";

   // compare : <, >처럼 두 문자열을 비교해서, 사전상의 순번을 숫자로 표현하는 함수
   cout << comp1.compare(comp2) << endl;
   // 사전상으로 "자기보다 늦게" 와야 하는 문자열이 매개변수로 들어오면 -1
   cout << comp2.compare(comp1) << endl;
   // 사전상으로 "자기보다 빨리" 와야 하는 문자열이 매개변수로 들어오면 +1
   cout << comp1.compare(comp3) << endl;
   // 사전상으로 위치가 똑같으면 (=그냥 문자열이 똑같으면) 0 (==하고 동일)

   // 추가로 쓸 수 있는 짜투리 문자열 팀 2
   // str.clear(); ← 문자열을 싹 비우는 함수
   // str.replace(0, 12, ""); ← replace를 사용해서도 마치 erase처럼 문자열을 지울 수 있다
   cout << str << endl;
}
